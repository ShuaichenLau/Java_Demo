1.什么是SpringBoot框架
    SpringBoot是一个快速整合第三方框架,简化xml,完全采用注解化.
    内置http服务器(jetty和tomcat undertow) 最终是以Java应用程序执行的.

    重点:快速整合第三方框架  内置http服务器

SpringBoot  快速开发框架,快速整合三方框架(maven子父依赖关系)
SpringCloud 微服务框架 rpc远程框架调用
SpringCloud 底层依赖于SpringBoot实现微服务接口
(SpringBoot Web组件集成SpringMVC框架),采用SpringMVC书写接口

微服务==>http接口 服务治理 注册中心 客户端调用 网关 断路器...

    注解在什么时候产生?Spring3.0以上(提供注解)
    SpringMVC内置注解加载整个SpringMVC容器
    
    Java语言操作SpringMVC配置初始化
    使用Java代码编写SpringMVC配置初始化
    Java语言创建tomcat 加载class


Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。
默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。


分析SpringBoot分析原理


SpringMVC的请求流程
    ⑴ 用户发送请求至前端控制器DispatcherServlet
    ⑵ DispatcherServlet收到请求调用HandlerMapping处理器映射器。
    ⑶ 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
    ⑷ DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
    ⑸ 执行处理器(Controller，也叫后端控制器)。
    ⑹ Controller执行完成返回ModelAndView
    ⑺ HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
    ⑻ DispatcherServlet将ModelAndView传给ViewReslover视图解析器
    ⑼ ViewReslover解析后返回具体View
    ⑽ DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
    ⑾ DispatcherServlet响应用户。


DNS解析IP过程
    1.浏览器会检查缓存中有没有这个域名对应的解析过的IP地址.如果缓存中有,这个解析过程就会结束.
        浏览器缓存域名也是有限制的,不仅浏览器缓存大小有限制的,而且缓存的时间也有限制,通常情况下为几分钟到几小时不等.
        域名被缓存的时间限制可以通过TTL属性来设置.这个缓存时间太长和太短都不好.
        如果域名解析的IP发生了变化,会导致被客户端缓存的域名无法解析到变化后的IP地址,以致于该域名不能正常解析
        如果设置时间太短,会导致用户每次访问网站都要重新解析一次域名.
    2.如果用户浏览器缓存中没有数据,浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果.
        其实操作系统也有域名解析的过程,windows中有hosts文件来设置,linux中在/etc/hosts文件来设置.(域名劫持)
    3.如果本地无法解析时,就要用到配置的DNS服务器地址了,这个DNS服务器地址一般都会缓存域名解析结果,当然缓存时间也是受到域名的失效时间来控制的.大约80%的域名解析请求到这里就会结束了.LDNS 本地区域域名服务器
    4.如果LDNS本地区域域名服务器没有命中,则直接到Root Server域名服务器请求解析.
    5.Root Server 根域名解析服务器返回本地域名服务器一个所查询的主域名服务器(gTLD Server)地址.gTLD是国际顶级域名服务器,如.com、.cn、.org等.
    6.本地域名服务器LDNS再向上一步返回的gTLD服务器发送请求
    7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，例如用户在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成
    8.Name Server域名服务器会查询存储的域名和IP映射关系表,在正常的情况下根据域名查到目标IP地址.连同一个TTL值返回给DNS域名服务器
    9.返回该域名对应的IP和TTL值 LDNS会缓存这个域名和IP的对应关系.缓存时间由TTL值来控制.
    10.把解析的结果返回给用户,用户根据TTL值缓存在本地系统缓存中,域名解析过程结束


正向代理 反向代理
正向代理隐藏了真实的请求客户端。服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。
    用浏览器访问http://www.google.com时被墙了，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。
反向代理隐藏了真实的服务端，当我们请求 ww.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，
    ww.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。

外网映射工具 https://natapp.cn

Nginx应用场景
    http服务器### 使用Nginx做静态服务器 图片服务器
    虚拟主机配置 将一台服务器,拆封多个网站部署.
    反向代理(负载均衡) 使用反向代理隐藏真实IP地址访问  负载均衡(集群)能减少单台服务器的压力 提交容灾能力 故障转移(重试机制幂等问题,健康检查(tcp http 心跳检测))
    安全配置
使用Nginx搭建API网关###解决网站跨域###
使用Nginx实现网站动静分离
使用Nginx实现防止DDOS(安全控制)
使用Nginx配置缓存(Http)


Nginx虚拟主机配置
    Nginx.conf配置解释
        http模块
            Server  作用 内部创建服务器 监听端口
            name    配置域名
            localtion   匹配拦截URL地址 配置拦截技术, localtion / {}拦截后跳转根目录 一般是资源目录文件 html文件
            index   默认首页地址 index.html
            root    表示存放Nginx的根目录 默认文件夹

基于域名区分项目路径
基于端口区分项目路径

Nginx的反向代理(基于Nginx实现反向代理)
    反向代理作用 提高安全性(隐藏真实服务器IP地址)
    proxy_pass 反向代理转发的真实IP地址 http;//127.0.0.1:80
    抓包工具无法抓取内部转发请求

Nginx七层负载均衡

Nginx主要作用是反向代理
    网关作用权限控制(互联网安全架构设计 黑名单 白名单系统)

外网网关Nginx
内网网关zuul

1.什么是负载均衡?
    使用负载均衡
        四层负载均衡器(基于传输层,也叫作基于TCP协议实现负载均衡,LVS(软负载)和F5硬件负载)
        七层负载均衡器(基于应用层,也叫作基于http协议实现负载均衡)Web服务实现负载均衡
2.为什么要用负载均衡
    解决高并发,将所有请求拦截到负载均衡器,在有负载均衡器采用负载均衡算法(轮询 权重 IP绑定)
3.负载均衡给我们带来的问题
4.负载均衡算法


四层负载均衡器和七层负载均衡器的区别:
    四层负载均衡器 主要在传输层实现负载均衡 主要针对于TCP协议
    七层负载均衡器 主要在应用层实现负载均衡 主要针对于HTTP协议

Nginx通过UpStream Server 配置多个upstreamServer实现负载均衡机制
失败重试机制:当upstream server(真实业务逻辑访问的服务器)出现超时或者服务器不在线的情况下,是否考虑重试机制(补偿机制)
服务器心跳检测:当upstream server 监控检测 心跳检测
    被Nginx代理最后真实访问的服务器
    负载均衡算法:
        轮询    每个请求按时间顺序逐一分配不同的后端服务器,如果后端某台服务器宕机,自动剔除故障系统(故障转移),使用户访问不受影响.
        轮询权重    weight的值越大分配到的访问概率越高,主要用于后端每台服务器性能不均衡的情况下.或者是为主从的情况下设置不同的权重,达到合理有效的利用主机性能资源.
        ipHash 每个请求按照ip的hash分配,使来自同一个ip的访客固定使用同一个后端服务器,并且有效解决session共享的问题,俗称ip绑定.
        fair(第三方)    fair是根据页面大小和加载时间长短智能的进行负载均衡,也就是根据后端服务器的响应时间来分配请求.响应时间短的优先分配.
            (Nginx不支持此算法,如果需要,须安装upstream fair模块)
        url hash(第三方) 按访问的url的hash结果来分配请求,使每一个请求定向到一台后端服务器,可以进一步提高缓存服务器的效率.
            (须安装Nginx的hash软件包)

服务器集群(分布式中常见问题)
    1.分布式Session一致性问题
    2.分布式Job幂等性问题
    3.分布式生成全局ID
    4.分布式锁解决方案
    5.分布式配置中心
    6.分布式日志收集系统

consul+upsync+nginx 实现动态负载均衡 无需停止Nginx 以及Nginx -s reload命令
传统配置都存放在项目中,这样做是有弊端的.假设在生产环境中修改配置文件出现错误,这就需要重新改项目配置文件,重新打包.
分布式领域中###分布式配置中心,将配置文件解耦出来.可以实现动态负载均衡,动态修改配置文件.

传统方式Nginx配置负载均衡,弊端:如果upStream需要扩展新的服务器,必须要重启Nginx才能获取到最新的配置
所以使用不用重启Nginx的方式,动态获取Nginx配置.

搭建一台专门存放动态upstream配置服务器###
可配置  能够灵活扩展###分布式配置中心###设置jdbc连接实现懒加载的效果
实现修改UPStream配置,动态获取Nginx Upstream.


Nginx可以通过正则表达式
    限制浏览器访问 限制拦截IP访问
拦截IP地址和浏览器原理:判断请求服务useAgent字段

Nginx外网配置环境 二级域名
大型互联网中 根据项目拆分域名 比如会员项目 订单项目 支付项目

consul是用go语言编写,实现分布式服务治理与服务发现功能.
类似实现分布式服务治理与服务发现的有zookeeper  Eureka

SpringCloud支持zookeeper Eureka Consul服务注册与发现

服务注册与发现应用场景:微服务rpc远程调用###对服务实现服务治理(注册中心)
注册中心(存放IP地址和端口)
Order key去注册中心上查找对应的IP地址和端口号 本地实现RPC远程调用

Nginx+Consul+UpSync 实现动态负载均衡原理
思考
    1.搭建ConsulServer专门存放负载均衡注册配置信息
    2.nginx间隔时间动态获取最新的ConsulServer配置信息

Nginx与LVS有什么区别?
    Nginx是七层负载均衡 主要是针对于应用层负载均衡(http),在1.9之后开始支持对四层负载均衡支持
    LVS是四层负载均衡,主要针对传输层负载均衡.
    LVS应用场景比Nginx 负载均衡引用场景更加广泛,而且LVS支持所有服务负载均衡业务功能.

lvs+keepAlive+nginx 实现高性能负载均衡集群
    LVS是一种四层负载均衡器 软负载均衡器 可以完成所有的负载均衡业务需求:比如数据库 WEB服务 虚拟化IP技术 意思是"Linux虚拟服务器"
    LVS可以实现负载均衡,但是不能够进行健康检查.
    keepAlived 是在LVS基础之上 实现心跳检测 监控服务器实现故障转移,如果服务器发生宕机的时候,可以尝试自动尝试脚本.如果多次重试还是失败的状态,会发送邮件给运维人员(高可用)
使用Nginx+keepAlived搭建双机主从热备实现7*24小时运行

1.如果客户端发送请求到Nginx服务器,如果Nginx承受不了会怎么办?限流机制
    Nginx实现集群 服务降级 熔断策略
2.如果项目发版的时候,这时候用户是否能访问?
    无法访问 上线项目无法访问 进行版本回滚

LVS抗负载能力比Nginx要强大,而且LVS是管理Nginx集群关系.
    思考:如果Nginx实现集群,那么客户端是访问哪个Nginx服务器? 通过LVS虚拟VIP技术实现负载均衡算法


面试遇到项目流程
1.搭建高可用双机主从热备
2.搭建两个Nginx实现7*24小时运行双机主从热备
3.keepAlive是基于LVS做心跳检测

当项目在生产环境上的服务器发生宕机的情况?是怎么处理?
    如果心跳监测Nginx没有启动的话,那么KeepAlived自动实现重启脚本,
    如果我重启Nginx多次还是失败的情况,该如何处理?(KeepAlived配置发送邮件给运维人员 通知给运维)

什么是网站动静分离架构模式?
    网站动静分离其实就是将一个系统中的动态资源和静态资源分离

动态资源与静态资源区别
    静态资源:是当用户多次访问的时候,html源代码不会发生改变
    动态资源:是当用户多次访问的时候,html源代码可能会发生改变
    最终区别:用户访问时候,html源代码是否发生改变.
伪静态:如果网站想被搜索引擎搜索到,动态页面静态技术freemark模板引擎技术

动静分离应用场景
    互联网公司高并发场景中 
        静态资源一个服务器(css img js)
        动态资源一个服务器(后端代码)

为什么要使用动静分离?
    传统网站架构模式:jsp html img css js全部都存放在一个服务器上
    把静态资源和动态资源存放在同一台服务器上

搭建动态分离原理?
使用Nginx+tomcat实现网站动静分离.
Nginx的localtion正则案例
配置nginx.conf的localtion中root表示其路径
如何区分是静态资源请求和动态资源请求?
静态资源部署在Nginx上,Root.
静态资源存放在Nginx
使用域名区分静态资源请求与动态资源请求
    static.domain.com
    www.domain.com

网站动静分离的原理:
    如何区分是静态资源请求和动态资源请求.
    静态服务器 使用Ngix实现静态服务器
    动态服务器 使用Tomcat实现动态服务器
Nginx实现静态服务器比Tomcat实现动态服务器性能要高很多.


动静分离与前后分离区别:
    动静分离:动态资源与静态资源分离,不会部署在同一台服务器上
    前后分离:网站架构模式,微服务开发基于SOA面向于服务器开发,后台和前端都采用调用接口方式.
        将一个项目拆分成一个控制WEB(前端)和接口(后端),最终使用rpc远程调用技术.
    视图层和业务逻辑层拆分,中间采用rpc远程调用技术.

在互联网公司项目中,静态资源url后面会加上一个时间戳?
    其作用是"控制缓存".防止浏览器缓存
    最终目的是为了控制项目上线的时候,静态资源与老的浏览器缓存静态资源避免冲突
    解决办法:加时间戳 规范t=项目上线时间毫秒数
304走本地缓存 状态码原理
    默认浏览器图片缓存是7天.
    一般来说在服务器上线的时候,都会在静态资源上加上时间戳来强制更新最新的资源.


使用Hystrix实现服务隔离
    服务降级 限流 熔断
		rpc远程调用中如何防止服务雪崩效应
		Hystrix是一个微服务中关于服务保护框架,在分布式中能够实现对服务一个容错.
    容错概念:服务在发生不可用的时候,出错之后处理方案.有一个预备方案

减少服务与服务依赖关系(不是在业务上依赖).防止服务雪崩效应,最终以服务降低,熔断,限流.
服务雪崩效应:当一个服务突然收到高并发的请求,tomcat服务器如果承受不了,产生服务堆积,可能会导致其他服务不可用.

Hystrix产生的背景(微服务高并发场景):
    服务保护,当服务产生堆积的时候,对服务实现保护功能
    堆积请求:假设默认tomcat最大线程池是50,尝试第51个请求时候,该请求会堵塞.大量请求正在等待,如果堆积请求过多,可能会造成服务器瘫痪.

tomcat底层是http+线程池,每个线程都是独立的请求.
举例场景:Hystrix针对微服务保护矿机.涉及到服务之间rpc远程调用.
订单与会员服务实现rpc调用.
微服务中rpc远程调用使用http技术通讯,采用restful协议,底层可以httpclient实现rpc远程通讯.
如果在微服务中没有处理好雪崩效应,那么可能会导致一串联依赖关系的服务产生等待.(考虑每个服务器性能不一致)

RPC与本地调用区别:
    rpc远程调用一般是可以跨平台采用http协议,因为http协议底层使用socket技术,只要语言支持socket技术,就可以相互进行通讯.
    比如:Java语言开发的接口,http协议,然后别人可以使用C#语言可以调用http协议.开放平台接口采用http协议,因为能支持更多的语言调用
本地调用只能支持Java语言与Java语言开发使用虚拟机与虚拟机之间通讯.

高并发限流
    互联网限流特技算法   计数器(滑动窗户计数器)    令牌通(RateLimiter+整合SpringBoot)   漏桶算法    应用层限流(Nginx)

服务降级:在高并发情况下,防止用户一直等待,使用服务降级的方式(直接返回一个友好的提示给客户端,调用fallback)

服务熔断:目的是为了保护服务,在高并发的情况下,如果达到一定极限(可以自己设置阈值),如果流量超出了设置阈值,然后直接拒绝访问,保护当前服务.使用服务降级.服务熔断和服务降级一起使用.

服务隔离:雪崩效应产生原因,因为在默认情况下,只有一个线程池维护所有的服务接口,如果大量的请求访问同一个接口,达到tomcat线程池默认极限,可能会导致其他服务无法访问.

服务限流:解决服务服务雪崩效应,使用服务隔离机制(线程池方式和信号量方式)
    使用线程池方式实现隔离的原理:相当于每个接口(服务)都有自己独立的线程池,因为线程池互不影响,这样就可以实现解决服务雪崩效应.
    信号量方式






