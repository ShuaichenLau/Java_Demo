@RestController 和 @Controller的区别
    @RestController是组合注解,是@ResponseBody注解和@Controller注解的组合.

count(1) count(*) count(列名)的区别
    从执行计划来看，count(1)和count(*)的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。
    如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。
    因为count(*),自动会优化指定到那一个字段。所以没必要去count(1)，用count(*)，sql会帮你完成优化的。
    在执行效果上:
        1.count(1)会统计表中所有的记录数 (包含字段为null的记录);
        2.count(字段)会统计该字段在表中出现的次数,忽略字段为null的情况 (不统计字段为null的记录);
        3.count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL;
        4.count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL;
        5.count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    在执行效率上:
        1.列名为主键,count(列名)会比count(1)快;
        2.列名不为主键,count(1)会比count(列名)快;
        3.如果表多个列并且没有主键,则count(1)的执行效率要优于count(*);
        4.如果有主键,则select count(主键)执行效率是最好的;
        5.如果表只有一个字段,则select count(*)执行效率是最好的;

1、equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱
2、当两种不同类型用==比较时，包装器类的需要拆箱， 当同种类型用==比较时，会自动拆箱或者装箱



1 JUC是怎么用的?
    a.线程间通信工具类,Semaphore、CountDownLatch、Future.在写多线程高并发的程序时，结合通信工具和锁把线程编排的符合你的预期执行
    b.锁,JUC提供了某些场景下比synchronized更合适的高级锁出现,包括读写锁 互斥锁等等,多数基于cas这种乐观锁实现,性能要由于synchronized内置锁,而且Condition更灵活可控.
    c.原子包装类
    d.线程安全的集合 基于锁分解、分段锁、CAS等机制性能优良且线程安全的集合类，一般在多线程业务中，只要有共享访问的集合，可能不管三七二十一直接用这些同步集合
    e.线程池工具类
2 用过哪些设计模式?
    单例模式 双重校验锁 Emun枚举
    抽象工厂模式 比如车险 农险 人寿险 等等,它们险种不一样,但是都有一种同样的抽象概念,比如说都有相同的保险起止期,等等这些.把相同的属性抽象成父类,特有的属性为子类特有.
    生产者消费者模式 比如说kafka mq 以及听云产品业务前后端分离架构
3 1.8 JVM有哪些优化
4 1.7 1.8 currentHashMap有什么优化
5 提交事务 事务回滚是怎么弄的
    MySQL事务
    https://www.runoob.com/mysql/mysql-transaction.html
6 分布式事务是怎么做的?
7 redis 热搜排序是怎么做的
8 线程池 线程的创建方式
    线程的创建方式
        a.实现Runnable接口
        b.继承Thread类
        c.实现Callable接口
9 object有哪些方法
10 @SpringBootApplication注解有什么作用
11 mq (这个我说不是很了解  只是写过简单的demo)
12 缓存穿透 雪崩 是怎么解决的
13 redis有哪些应用场景
14 创建对象有哪些方式
15 redis持久化的问题
16 MySQL索引是怎么用的 怎么创建索引 索引原理是什么  SQL的优化 explain
17 MySQL  一二三范式  数据库是怎么设计的
18 SpringIOC  AOP

内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存

内存泄漏 内存溢出
泄漏就是内存申请后，用完没有释放，造成可用内存越来越少。
溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常，严重的，攻击者可以以此获取程序控制权。

数据库事务特性ACID
	A原子性
	C一致性
	I隔离性
	D持久性

