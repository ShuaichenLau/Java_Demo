@RestController 和 @Controller的区别
    @RestController是组合注解,是@ResponseBody注解和@Controller注解的组合.

count(1) count(*) count(列名)的区别
    从执行计划来看，count(1)和count(*)的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。
    如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。
    因为count(*),自动会优化指定到那一个字段。所以没必要去count(1)，用count(*)，sql会帮你完成优化的。
    在执行效果上:
        1.count(1)会统计表中所有的记录数 (包含字段为null的记录);
        2.count(字段)会统计该字段在表中出现的次数,忽略字段为null的情况 (不统计字段为null的记录);
        3.count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL;
        4.count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL;
        5.count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    在执行效率上:
        1.列名为主键,count(列名)会比count(1)快;
        2.列名不为主键,count(1)会比count(列名)快;
        3.如果表多个列并且没有主键,则count(1)的执行效率要优于count(*);
        4.如果有主键,则select count(主键)执行效率是最好的;
        5.如果表只有一个字段,则select count(*)执行效率是最好的;

1、equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱
2、当两种不同类型用==比较时，包装器类的需要拆箱， 当同种类型用==比较时，会自动拆箱或者装箱



1 JUC是怎么用的?
    a.线程间通信工具类,Semaphore、CountDownLatch、Future.在写多线程高并发的程序时，结合通信工具和锁把线程编排的符合你的预期执行
    b.锁,JUC提供了某些场景下比synchronized更合适的高级锁出现,包括读写锁 互斥锁等等,多数基于cas这种乐观锁实现,性能要由于synchronized内置锁,而且Condition更灵活可控.
    c.原子包装类
    d.线程安全的集合 基于锁分解、分段锁、CAS等机制性能优良且线程安全的集合类，一般在多线程业务中，只要有共享访问的集合，可能不管三七二十一直接用这些同步集合
    e.线程池工具类
2 用过哪些设计模式?
    单例模式 双重校验锁 Emun枚举
    抽象工厂模式 比如车险 农险 人寿险 等等,它们险种不一样,但是都有一种同样的抽象概念,比如说都有相同的保险起止期,等等这些.把相同的属性抽象成父类,特有的属性为子类特有.
    生产者消费者模式 比如说kafka mq 以及听云产品业务前后端分离架构
3 1.8 JVM有哪些优化
4 1.7 1.8 currentHashMap有什么优化
5 提交事务 事务回滚是怎么弄的
    MySQL事务
    https://www.runoob.com/mysql/mysql-transaction.html
6 分布式事务是怎么做的?
7 redis 热搜排序是怎么做的
8 线程池 线程的创建方式
    线程的创建方式
        a.实现Runnable接口
        b.继承Thread类
        c.实现Callable接口
9 object有哪些方法
10 @SpringBootApplication注解有什么作用
11 mq (这个我说不是很了解  只是写过简单的demo)
12 缓存穿透 雪崩 是怎么解决的
13 redis有哪些应用场景
14 创建对象有哪些方式
15 redis持久化的问题
16 MySQL索引是怎么用的 怎么创建索引 索引原理是什么  SQL的优化 explain
17 MySQL  一二三范式  数据库是怎么设计的
18 SpringIOC  AOP

内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存

内存泄漏 内存溢出
泄漏就是内存申请后，用完没有释放，造成可用内存越来越少。
溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常，严重的，攻击者可以以此获取程序控制权。

数据库事务特性ACID
	A原子性:事务是一个完整的操作.事务的各步操作是不可分的(原子的);要么都执行,要么都不执行
	C一致性:当事务完成时,数据都必须是一致的状态
	I隔离性:对数据进行修改的所有并发事务都是彼此隔离的,这表示事务必须是独立的,不应以任何方式依赖于或影响其他事务
	D持久性:事务完成时,对数据库的修改被永久保持,事务日志能保持事务的永久性.

第一范式:
    保持每列的原子性,每一列都是不可拆分的最小单元.(最小的单元,列都是不可再拆分的)
第二范式:
    满足第一范式,并且表中非主键列不存在对主键的部分依赖(每个表只描述一件事)
第三范式:
    满足第二范式,并且表中的列不存在对非主键列的传递依赖.

redis持久化
    aof append的方式持久化
    rdb 生成快照的方式
save命令
    同步生成快照 同时会阻塞所有来自客户端请求,如果数据较大的话,会导致服务长时间不能响应
bgsave命令
    异步生成快照 同时接收所有来自客户端的请求,通过lastSave命令获取最近一次成功执行快照的时间

表单重复提交问题
    rpc远程调用的时候 网络发生延迟的时候 可能会有重试机制
互联网API接口幂等性设计 ## 如何纯手写一个互联网API接口幂等性框架
保证互联网接口幂等性问题
API接口与RPC远程http协议
API幂等性产生的原因:(接口重复提交的问题) 保证接口唯一性 使用token(令牌)保证临时且唯一(15分钟-120分钟)
分布式session解决方案 使用redis+token
token如何生成 token_时间戳(雪花算法ID)  分布式场景问题

如何保证外网开放接口的安全性
    1.搭建API网关控制接口访问权限
    2.开放平台设计oauth2.0协议(安全认证) QQ认证 第三方联合登录
    3.采用https加密传输协议(使用Nginx配置Https)
    4.API接口数字签名(移动的接口)非对称加密RSA 防止抓包分析修改数据
    5.基于令牌方式实现API接口调用.基于accessToken实现API调用(微信开发)

基于AccessToken方式实现开放平台
    开放平台提供者:需要提供为每个合作机构提供对应的AppID AppSecret
        需要AppId+AppSecret生成对应的accessToken
    1.需求:A需要调用B的服务器(B需要提供开放外网访问接口)
    2.基于令牌方式实现
    AppId (第三方合作机构) 区分不同的机构 永远不能改变
    AppSecret 在传输中实现加密功能(密钥) 可以发生改变
获取AccessToken 开发步骤
    使用对应机构的 AppId + AppSecret 对应生成AccessToken
    使用对应的AccessToken调用第三方接口
    写一个定时Job 每间隔1小时刷新AccessToken


前端:控制我们整个页面跳转 数据展示 页面渲染
后端:核心应该写我们的业务逻辑层,提供数据源

实现前后端分离架构模式.整体项目,采用前后端分离架构模式,前端调用后端接口实现对页面的跳转 数据渲染

前端:看公司API文档接口文档 根据接口文档展示数据
    交互使用http+json

微服务架构模式特征:使用前后端分离架构,目的实现效率开发
前端架构模式:能够去实现对我们的接口复用.

Oauth2.0应用场景 授权管理(QQ 微信联合登录)
oauth2.0认证原理
搭建微信授权联合登录
不同的开放平台对接的oauth2.0协议流程都是相同,无非接口地址不同

===========================================================================
oauth2.0原理(appid,appsecret,access_token,openid,回调地址)
OAuth2.0总体处理流程
1 第一步：用户同意授权，获取code
2 第二步：通过code换取网页授权access_token
3 第三步：刷新access_token（如果需要）
4 第四步：拉取用户信息(需scope为 snsapi_userinfo)

步骤:
    1.在微信开放平台申请对应的appid信息
    2.客户端生成登录授权连接
    3.用户在确认微信登录之后,跳转回到回调地址(配置域名权限)
    4.获取授权码code,使用授权码获取对应的AccessToken(调用腾讯接口权限)
    5.使用AccessToken+openId获取用户相关信息(openid 开放userId)
============================================================================

接口网关(微服务SpringCloud组件Zuul网关) 注册中心 负载均衡客户端 http客户端调用工具 链路 网关
网关(过滤器 拦截器)
    网关包含过滤器实现功能,还可以实现Nginx基本功能 反向代理 负载均衡ribbon(本地客户端)
    Nginx是软负载ribbon本地客户端负载均衡(Dubbo原理分析)
网关核心应用场景:路由地址 反向代理 黑名单与白名单 授权安全

Zuul框架使用Java语言编写 Nginx使用C语言编写
Nginx功能比Zuul功能更加强大 Nginx实现反向代理功能性能比Zuul好
SpringCloud 注册中心 生产者消费者 断路器Zuul(网关) 分布式配置中心
Zuul框架是微服务里面某个组件 网关
Nginx针对于服务器.
Nginx不能替代Zuul 日志 权限控制 限流 安全限制(黑名单 白名单)

基于Nginx搭建网关 
    流程:基于域名区分不同反向代理或者局域项目名称区分不同的反向代理
    网关可以解决跨域问题 跨域可以使用网关实现 实现原理:保证域名相同,使用Nginx区分不同的项目路径进行转发跳转.

RPC远程通讯调用原理
基于SpringCloud Zuul搭建网关
    SpringCloud是一套微服务框架 consul实现注册中心(Go语言开发)

传统服务与服务之间通讯url管理 负载均衡 熔断机制 服务降级
使用服务治理管理每个服务与服务之间的依赖关系(注册中心)

服务(SOA)相当于把共同的业务逻辑抽取出来,以接口的形式发布 服务化
注册中心:consul eureka zookeeper

什么是http请求?
    Http协议实际上对Socket技术封装 请求与响应

重定向底层实现原理:为什么会产生2次请求.请求过程是怎么样?
    客户端向服务器发送请求的时候,服务端如果重定向的话,返回状态302给客户端,在响应头中存放localtion对应的值 就是 重定向地址,客户端收到状态码302,直接浏览器本地进行访问
    浏览器获取响应头状态码为302,读取响应头中的localtion,本地(浏览器)实现访问调用


常用加密算法:对称加密和非对称加密 https底层实现(混合加密算法对对称加密和非对称加密)
    对称加密:加密和解密都是同一种密钥.相对非对称密钥不是很安全,但是效率高 DES AES

非对称加密:是会生成一对密钥 公钥(客户端)和私钥(服务端).
    1.如果使用公钥加密,使用私钥解密
    2.如果使用私钥加密,使用公钥解密

加密的目的为了防止非法获取明文数据,防止篡改数据. 使用验签和令牌
https底层协议使用SSL协议,也是使用对称加密进行传输(浏览器自动生成密钥)
混合算法(对称加密和非对称加密)

Socket三次握手
https协议底层采用默认端口号443 or 8443
SSL安全认证传输步骤:
    1.验证证书是否有效
    2.如果证书有效,则会随机生成一个随机数(随机数指的就是对称加密的密钥)
    3.使用公钥加密随机数(密钥)发给服务器端
    4.服务器使用私钥解密随机数(密钥)
    5.服务器端使用该随机数作为密钥加密数据给客户端
    6.如果客户端使用该随机数解密成功
    7.客户端与服务器端通讯使用该随机数(密钥)进行对称加密传输.

证书的作用:
    1.返回一些加密信息
    2.颁发者机构 加密算法 验证 证书有效期
总结:Https分别对称加密和非对称加密
    非对称加密目的是确保对称加密密钥的安全
    确保安全之后使用对称加密传输

http与https协议区别
    端口号:https是443 http是80
https采用加密传输 http采用明文传输
https采用混合加密算法(对称加密 非对称加密)
https比http协议更加安全,但是https效率没有http高    

Nginx配置Https证书
    ssl:on
    listen 443
    ssl...各种配置

解决跨域问题
    1.httpclient转发(不靠谱)
    2.使用过滤器允许接口跨域 响应头设置
    3.Jsonp不支持post 属于前段解决
    4.Nginx解决跨域问题保持域名端口一致性
    5.Nginx可以通过配置文件解决跨域问题
    6.基于微服务网关解决跨域问题,需要保持域名和端口一致性
    7.使用网关代码允许所有服务可以跨域
    8.SpringBoot的注解 @CrossOrigin




分布式缓存架构设计思想
    
Session是存放在服务器端(保存在单个JVM中),返回Session(响应头),客户端存放在SessionId,下次请求的时候直接使用对应的SessionId从服务器中查询对应的Session
分布式Session(Session共享的问题) --直接使用Token

如何写个单个JVM缓存框架?Session Key Value
Map 过期时间 基于Map集合实现JVM缓存框架

Ehcache的主要特性
    多种缓存策略 快速 简单
    缓存数据有两级:内存和磁盘,因此无需担心容量问题
    缓存数据会在虚拟机重启的过程中写入磁盘
    可以通过RMI 可插入API等方式进行分布式缓存
    具有缓存和缓存管理器的侦听接口
    支持多缓存管理器实例,以及一个实例的多个缓存区域
    提供hibernate的缓存实现

缓存与db不同步的情况下如何解决?
    荡魂村需要被清理时(比如空间占用已经接近临界值了),需要使用某种淘汰算法来清理数据.
    FIFO 先进先出 判断被存储的时间 离目前最远的数据优先被淘汰.
    LRU 最近最少使用 判断最近被使用的时间 目前最远的数据优先被淘汰
    LFU 最不经常使用 在一段时间内,数据被使用次数最少,优先被淘汰

@CacheConfig(cacheNames={"userCache"})
使用@Cacheable注解配置缓存.
@CacheConfig 配置缓存基本信息,cacheNames缓存名称.
@Cacheable 该方法查询数据库完毕之后,存入到缓存中.

如何解决缓存与db不同步的问题
    1.直接重启服务器
    2.主动通知

在项目中什么场景下会发生缓存与db不同步的问题
update(修改)或者del(删除)
先修改,修改成功之后,在主动清理缓存(在同一个事务中)

改完了再清缓存 如果修改失败 定时JOB 健康检查

EHcache 主流集群实现方案:
    RMI JMS方式.
EHcache默认不是支持共享 分布式默认支持共享

RMI和RPC理念是相同的,RMI是Java语言中JVM与JMV实现远程调用方式.(不能跨平台)
RPC也属于远程调用技术 PRC底层使用socket 因为http协议底层使用socket技术(基于二进制传输),支持跨语言跨平台.

目前来说大多数都是用rpc技术.

redis是一个非关系型数据库(NoSql) 内存数据库, 以key value方式进行存储.Redis以单线程方式进行存储.可以保证线程安全问题.可以设置有效期,使用持久化机制保证数据高可用.
redis使用场景
    1.令牌生成(临时 有效期)
    2.短信验证码(临时 有效期)
    3.热点数据(使用redis减轻查询数据库压力)
    4.使用redis实现消息中间件(发布订阅)
    5.分布式锁(使用zk或者redis实现分布式锁)
    6.网站计数器(因为redis是单线程,在高并发情况下,保证记录全局count唯一性)
redis解决雪崩效应
redis多种集群方案
redis持久化机制
redis哨兵机制高可用


redis 允许ip方式 redis.conf  bind属性

redis 5种基本类型
    String hash list set zset

Spring整合redis
redis默认16个库,默认连接0库 以不同的业务区分不同的库

1.什么是主从复制(主Master) (从Slave)
    将服务器分为主服务和从服务器,住的服务可以允许做读写操作,从服务器只允许做读的操作
2.主从复制应用场景:
    集群(多台服务器) 读写分离 日志备份 高可用
3.什么是读写分离
    读和写分库连接,读一个库,写一个库.互相不想赢,增加整体吞吐量
    主服务器可以做写,从服务器可以读.
4.读写分离问题:集群同步问题(redis已经自带)
    
哨兵机制的作用:管理集群redis 监控选举策略 心跳检测 (独立的一个应用程序)
环境配置:实现3台不同服务器的redis实现集群(克隆)  --直接安装一台,后面两台全部克隆

SpringBoot+redis+ehcache 实现二级缓存
    ehcache本地缓存
    redis分布式缓存共享
    一级缓存(ehcache) 和二级缓存(redis) 先走本地,如果本地没有在走网络.
redis与数据库的区别
    相同:都属于中间件形式
    不同点:存放介质 存放在内存中  数据库数据是存在硬盘上

ehcache的优点是本地内存获取.可以充当redis的二级缓存
    可以减轻redis的访问压力 也可以提高访问速度.
问题:过期时间如何控制?(如何同步)?
    一级缓存过期时间比二级缓存过期时间短
    redis和 ehcache 缓存值不同步 定时JOB MQ通知
    
常见redis集群方案对比
    持久化AOF RDB
    AOF是以日志形式记录文件(实时),效率低.
    RDB间隔(非实时),停止的会保存rdb日志文件.效率高(独立进程方式)
RedisCluster分片集群原理分析
虚拟机搭建RedisCluster集群
SpringBoot整合Redis集群

redis3.0之前和redis3.0之后差别大
    redis3.0之后默认支持了redis集群,3.0之前默认不值钱redis集群

redis集群方案:
    1.客户端分片技术(mycat)故障转移功能
    2.主从复制(实现集群)缺点:数据冗余,浪费内存,日志备份
    3.使用代理工具
    4.redis强烈推荐(redis-Cluster)redis3,0之后开始实现
搭建redis集群可以使用伪集群方式(基于端口号进行区分)

redis集群是否支持事务
    redis集群默认不支持事务 但是事务可以在单独节点上可以支持
常见redis攻击手段
redis雪崩效应产生原因
redis雪崩效应解决方案
    1.分布式锁(本地锁)
    2.使用消息中间件方式(最靠谱) 消息中间件方式可以解决高并发
        思路:如果大量请求进行访问的时候,如果redis没有值得情况下,会将该消息存放在消息中间件(异步)
        如果redis查询不到结果的时候,直接将消息扔给消息中间件
    3.一级和二级(redis+ehcache)
    4.均摊分配redis key的失效时间
redis穿透产生原因
redis穿透解决方案 

使用分布式锁(本地锁)解决雪崩效应
    当突然有大量的请求到数据库服务器的时候,进行对数据库服务请求限制.
    可以使用锁的机制,保证只有一个线程(请求)进行数据库的操作访问,否则情况直接排队等待.(如果是集群服务器的话,那么就需要使用分布式锁,单机版本可以使用本地锁)
    可以解决服务雪崩效应,但是会减少服务器吞吐量的问题.

redis穿透原理
    穿透问题产生的原因:客户端随机生成不同的key,在redis缓存中没有该数据,数据库中也没有该数据,这样话可以会导致一直发生JDBC请求连接.
    使用对应的key与数据库中数据不存在.
如何解决穿透问题?
    1.网关判断客户端传入对应的key规则,如果不符合数据库查询的规则会直接返回空
    2.如果使用的key数据查询不到结果的时候,直接在redis中存一份为null的结果.
        问题:如果以后数据库中存放在一个id为4,因为redis存放为null,数据库为4.
        答案:在存入id为4的时候,直接清除对应redis为4的缓存,然后在插入数据库中.

1.zookeeper是一个分布式协调工具(Java语言编写开源框架)
2.zookeeper应用场景
    a.命名服务(注册中心)Dubbo注册中心
    b.分布式配置中心(SpringCloud Config) 动态管理配置文件信息
    c.消息中间件 事件通知(类似于发布订阅功能)
    d.zookeeper分布式事务(全局协调者)
    e.zookeeper实现分布式锁
    f.zookeeper可以实现选举策略(哨兵机制)
    g.zookeeper实现本地动态负载均衡(Dubbo服务负载均衡原理)
    h.消息中间件集群管理(zookeeper)

注册中心都是集群版本 consul eureka zookeeper redis高可用
分布式系统核心在于服务治理 

1.zookeeper存储结构
    xml是怎么样的数据结构? 类似于树Node节点的结构
    zookeeper以节点方式进行存储,类似xml树状结构(目录结构)
    node是如何划分的,node(节点)节点路径、节点value
    节点路径(节点名称),接名称是否允许重复(不能) 保证整体路径的唯一(同一层要唯一)
    节点类型:临时节点 持久节点
        持久节点:创建节点永久的持久化在硬盘上
        临时节点:当前节点和会话连接保持,如果连接断开,该节点也会被删除(分布式锁原理底层用的就是临时节点)
        节点事件通知:每个节点都有事件通知,对该节点发生删除 修改 添加都会有事件通知.类似于消息中间件功能
2.基于zk实现动态本地负载均衡(Dubbo服务调用负载均衡)
    会员服务项目启动的时候回在zk上创建一个临时节点 节点名称itmayiedu_member对应的value:127.0.0.1:8080,127.0.0.1:8081
    订单直接在zk使用itmayiedu_member查询下面所有子节点,获取子节点后,本地在使用负载均衡算法实现调用

将服务注册到zookeeper上
    1.建立zk连接
    2.先创建父节点
        如果父节点不存在,直接创建父节点
    3.创建子节点(临时)

客户端从zk服务器端获取节点信息
    1.建立zk节点
    2.读取注册父节点信息
    
如何使用zookeeper实现分布式锁?思路?
    zookeeper实现分布式锁 使用临时节点实现.
实现步骤:多个JVM同时在zookeeper上创建同一个相同的节点(/lock),因为zookeeper节点是唯一的,
    如果是唯一的话,那么同时如果有多个客户端创建相同的节点/lock的话,最终只有看谁快速抢夺资源,谁就能创建/lock节点
    这个时候节点类型应该使用临时类型.

zookeeper如何获取锁?
zookeeper如何释放锁?
    使用watcher(事件通知)获取/lock已经被删除
zk连接不要强制关闭,会产生延迟.直接调用close(),产生延迟的概率非常小.
如果程序一直不处理完,可能导致死锁?可以设置有效期.可以看60秒session超时
rpc重试 一般重试3次


Nginx策略
    轮询 权重 随机 ip URL

并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。


Servlet 生命周期就是指创建 Servlet 实例后响应客户请求直至销毁的全过程.
Serlvet 生命周期的三个方法:init()–>service()–>destroy()，
Servlet生命周期的各个阶段: 实例化:Servlet 容器创建
Servlet 类的实例对象
初始化:Servlet 容器调用 Servlet 的 init()方法
服务:如果请求 Servlet,则容器调用 service()方法
销毁:销毁实例之前调用 destroy()方法

分布式Session一致性(服务器集群Session共享问题)
Session的作用? 记录用户信息(应用场景)
应用场景:JavaEE基础登录流程做法(账号密码登录成功之后,获取到userId 存放在Session 下次获取用户信息之后 直接从session会话中获取) 防止表单重复提交 

Session理解为JVM本地缓存  session存在服务器上 返回SessionId给客户端

Session原理?
Session常见的问题:
    浏览器关闭了Session?Session会失效么?

默认创建一个Session 默认值为true 没有找到对应的Session自动创建Session
HttpSession session = request.getSession();
session分为sessionid和sessionvalue
session本身是一个临时的 sessionId和token(令牌)非常相似  保证临时且唯一

(请求和响应过程)
服务器端接收到客户端请求 会创建一个session 使用响应头返回sessionId给客户端 浏览器获取到sessionId后保存到本地.cookie
(第二次请求)
客户端读取到本地的sessionId存放在请求头中 服务器端从请求头中获取到对应的sessionId,通过SessionId在本地session内存中查询

1.分布式Session问题 因为Session存放在服务器端 SessionId对应找不到Session
2.分布式任务调度平台(服务器集群之后如何保证定时JOB的唯一性)  幂等性
3.分布式锁解决方案 (全局ID)
    基于Zookeeper使用临时节点+事件通知
    基于redis setnx方式缺点: 不推荐 代码复杂 死锁
    redisson
    SpringCloud对redisson redis中提供很多关于分布式解决方案 分布式锁
4.分布式日志收集问题
    elk 大型的电商互联网内部分布式日志收集
5.分布式事务问题(跟集群没有关系) rpc远程通讯服务与服务之间实现事务管理.
    如何纯手写一个自己分布式事务解决框架 模仿lcn
6.分布式配置中心(跟集群没有关系) 
面试官经常问你道题:你在做项目的时候,遇到过哪些问题?


分布式服务器集群session共享问题
分布式session解决方案?
    可以直接使用cookie替代Session(不靠谱)
    使用Nginx 反向代理 IP hash IP绑定方式 同一个IP 只能在指定的同一个机器访问(没有负载均衡)
    使用数据库效率不是很高
    tomcat内置支持对session同步(不推荐) 同步可能会产生延迟
    使用Spring-Session框架相当于把我们Session缓存到redis中
    使用token替代Session功能

面试题:项目在发布时候,Session如何控制不失效?
    使用缓存框架 缓存Session的值(一级 和 二级)
    Spring-Session重写httpSession框架 将对应的值缓存到redis中 有点类似于一级缓存 二级缓存
    SessionId不同 它的域名也不同
    移动会话信息使用令牌token方式替代Session
    Token最终存放在redis中 redis支持分布式共享

基于token令牌方式解决Session共享
使用Zookeeper实现服务Master选举
    哨兵机制回顾:目的是为了主和选举策略 实现高可用
    主只能有一台主节点多个从节点
    原理:多个服务器在启动的时候,会在Zookeeper上面创建相同的临时节点,谁如果能够创建成功,谁就为主(因节点保证唯一),如果主服务器宕机之后,会话连接也会失效.其他服务器又开始重新选举.
    其他从节点使用事件监听,如果当节点被删除的情况下,这时候重新开始选举.


网站跨域请求问题
1.解决跨域问题使用jsonp
2.什么是跨域问题
    两个项目之前使用ajax(前端类似于后端技术HTTPClient)实现通讯,
    如果浏览器访问的域名地址与ajax访问的地址不一致的情况,默认情况下浏览器会有安全机制,这个机制跨域问题,会无法获取到返回结果.
    注意:每个项目的端口号是否相同
    如果ajax访问地址与浏览器访问域名和端口号都不同的情况下,默认浏览器会有安全策略,直接无法获取请求结果.
3.为什么会产生跨域问题
    浏览器跨域问题产生的原因,如果使用ajax请求使用第三方接口,如果ajax访问的接口域名和端口号与浏览器访问的域名和端口号不一致的情况下,就会产生跨域问题(属于浏览器安全策略)
    跨域不属于前端问题
    跨域问题,请求时可以访问的,但只是获取不到结果
4.如何彻底解决网站跨域问题
    使用jsonp解决跨域问题(只能支持get请求 不支持post请求) dataType:"jsonp"
    使用HttpClient进行转发(效率低 会发送两次请求 后端转发 避免跨域)
    设置响应头允许跨域 reponse.setHeader("Access-Control-Allow-Origin"."*");
    使用Nginx搭建API接口网关(因为保证域名和端口都一致,以项目区分反向代理到真是服务器地址)
        原理:保证域名和端口号都是相同的,根据项目区分不同名称使用nginx进行转发到真实服务器地址,可以彻底解决网站跨域问题,而且可以保证整套系统安全性的问题.
    使用Zuul微服务搭建API接口网关 SpringCloud
        原理:application.yml 项目名称区别不同项目地址 需要Eurke zk注册中心管理 zuul路由转发 

Nginx服务器模块
微服务通讯会产生跨域问题? rpc之间通讯会产生跨域问题?
    不会,因为走后端访问.


为什么要实现zookeeper集群呢?服务如果要实现集群的话?目的保证整套系统的一个高可用

服务器集群和注册中心集群的目的是什么?
相同点:都是为了保证高可用 如果某个服务实现宕机可以做故障转移fallback
服务器集群是为了解决高并发
注册集群担心如果是单台注册中心节点的时候,如果宕机之后可能导致整个微服务无法通讯
注册中心实际上服务治理 管理每个服务指向url地址

zookeeper实现集群选举原理?
zookeeper集群选举,角色领导(主) 跟随者(从) 只能保证有一个主节点,多个从节点,底层采用ZAB协议原子广播
    其实分为两种:
        恢复模式:如果主节点宕机后,在多个从节点中重新选举新的主节点
        广播模式:保证每个Server之间的数据同步

xxl-job-adminweb平台
定时任务调度(开发)
案例:定时任务调度案例
定时任务应用场景
    数据同步 交易信息 清除用户信息 定期发送报表数据 活动推送
主题:分布式任务调度平台 分布式领域中服务器集群的话 如何保证定时job幂等性
Java语言实现任务调度
    Thread TimerTask 线程池 quartz SpringBoot内置schedul

传统的定时任务与分布式定时任务区别
    传统定时任务特征:单点系统(JOB不需要集群)
定时任务在执行代码的时候中间突然报错了,使用日志记录错误,跳过继续执行
在使用定时JOB扫描日志错误记录,进行补偿信息.

定时Job在执行整个过程中都是报错的,导致整个job异常结束掉. (发送邮件 通知运维人员 警报)

传统定时任务与分布式定时任务区别
    传统定时任务特征:单一(没有集群)
    分布式定时任务调度

如何保证分布式Job幂等性
    1.使用zookeeper实现分布式锁
    2.在配置文件中启动定时job开关
    3.启动的时候使用数据库唯一标识(不推荐)
推荐使用分布式任务调度平台(核心) XXL-Job

xxl-job原理:执行器 任务管理
执行器:定时job实际执行的服务器地址.
任务管理:配置定时任务规则,路由策略,允许模式.

xxl-job admin平台 独立web服务器
1.在XXL-job admin平台创建执行器(job实际执行地址)
2.在XXL-job admin平台新建任务,填写对应的执行器
3.在job服务器代码中,使用JobHandler标识该类为job执行方法
4.如果有任务需要执行的时候,现在xxl-job admin执行一次,获取任务中的执行器.


传统配置文件有什么缺点?
    如果修改了配置文件,需要重新打包发布,重新发布服务,而且每个环境变更配置文件.
分布式配置中心?(Apollo 分布式配置中心 )
    将配置文件信息注册到配置中心平台上,可以使用分布式配置中心实时更新文件信息,统一管理,不需要重新打包发布.

SpringBoot客户端如何对应阿波罗服务器端


什么是分布式锁?(分布式锁解决方案)  核心:最终保证只能有1个JVM做操作
    采用数据库(不建议 jdbc性能不高)
    基于redis实现分布式锁(setnx)setnx也可以存入key,如果存入key成功返回1,如果存入的key已经存在了,返回0.
    多个客户端(JVM),使用setnx命令方式在redis上创建相同的一个key,因为临时节点路径是保证唯一,只要谁能够创建节点成功,谁就能获取到锁,没有创建成功节点,就会进行等待.
    基于zookeeper实现分布式锁 zookeeper是一个分布式协调工具 在分布式解决方案中.
    多个客户端(JVM),同时在zk上创建相同的一个临时节点,因为临时节点路径是保证唯一,只要谁能够创建节点成功,谁就能获取到锁,没有创建成功节点,就会进行等待.当释放锁的时候,采用事件通知给客户端重新获取锁的资源

解决分布式锁核心思路?
    在镀钛服务器集群中,只能有一个JVM进行做操作


redis setnx作用:也可以做写入操作 可以获取到返回结果 
该返回是1 表示key不存在 写入成功
该返回是0 表示key存在 写入失败
在redis key是保证唯一
如何释放锁? 在执行完成操作的时候 删除对应的key(redis挂了) 解决方法是给key设置有效期(过期时间) 设置过期时间的目的是为了防止死锁.

redis分布式锁与zookeeper分布式锁的区别
实现分布式锁最终是通过什么方式?(相同点) 在集群环境下,保证只允许有一个jvm进行执行
从技术分析 redis是nosql数据 主要特点是缓存
zookeeper是分布式协调工具,主要用于分布式解决方案
多个客户端(JVM)会在zk上创建同一个临时节点,因为zookeeper节点命令路径保证唯一,不允许出现重复,只要谁能够先创建成功,谁就能够获取到锁

redis使用setnx命令创建相同的一个key,因为redis的key保证唯一,不允许出现重复,只要谁能够先创建成功,谁就能获取到锁

释放锁:zook使用直接关闭临时节点session会话连接,因为临时节点生命周期与session会话绑定在一起,如果session会话连接关闭,该临时节点也会被删除.
如果该临时节点被删除,会重新进入到获取锁的步骤

redis释放锁:redis在释放锁的时候,为了确保是锁的一致性问题,在删除的redis的key的时候,需要判断锁的id才可以删除.

共同特征:如何解决死锁现象?
zookeeper使用会话有效期方式解决死锁现象
redis是对key设置有效期expire来解决死锁现象

性能 redis性能比zookeeper要好  redis是nosql数据库
可靠性 zookeeper更加可靠  因为redis有效期不是很好控制 可能会产生有效期延迟
    zookeeper临时节点先天性自带可控的有效期功能,所以相对来说zookeeper可靠性要比redis要好

rpc远程调用技术框架:
    httpclient springCloud dubbo grpc
    核心底层都是使用socket技术或者Netty实现

SOA架构特点:底层基于SOAP或者ESB(消息总线)实现,底层使用http或者https协议实现
WebService 是用http协议+xml (SOAP)
微服务是以json代替xml


服务注册:将服务信息注册到注册中心上
服务发现:从注册中心上获取服务信息
1.服务注册与实现原理在任何RPC远程框架中,都会有一个注册中心
2.注册中心概念:存放服务地址相关的信息(接口地址)
3.会员服务在启动的时候,会把当前服务基本信息比如服务地址和端口以别名方式注册到注册中心上去
4.消费者在调用接口的时候,使用服务别名也就是Serviced去注册中心上获取实际rpc远程调用地址
5.如果消费者获取实际rpc远程调用地址之后,再使用本地HttpClient技术实现调用
(首先会缓存在JVM内存中,默认情况下Eureka每隔30秒更新一次调用服务地址)

SpringCloud中支持以下3种注册中心 Eureka Consul zookeeper Dubbo(X) 
Dubbo支持常用两种Redis和zookeeper

服务提供者 提供服务接口
服务消费者 调用其他接口进行使用
一个服务可以作为提供者 也可以做消费者

微服务负载均衡:本地负载均衡

微服务非常核心的组件:服务治理中心

为什么会产生Eureka自我保护?
    为了防止EurekaClient与EurekaServer网络不通的情况下,EurekaServer误将EurekaClient剔除
分为两种角色 EurekaClient(注册客户端) EurekaServer(注册中心服务端)

服务自我保护机制:默认情况EurekaClient定时向EurekaServer发送心跳包(ping),
如果在EurekaServer在一定时间没有收到EurekaClient服务的心跳包,便从服务注册列表中剔除改服务.(默认90s时间)
但是在短时间内丢失了大量的服务实例心跳,这时候EurekaClient会开启自我保护机制,不会剔除该服务.(有可能是网络故障原因)
在自我保护机制中,为什么EurekaServer不会剔除该服务? 为了防止EurekaClient是可以正常访问,但是只是EurekaClient与EurekaServer端访问网络不通
在什么环境会开启自我保护机制?

本地环境建议禁止自我保护机制
生产环境建议开启自我保护机制

注册中心目的是为了做什么?(管理服务之间的依赖关系 服务治理 注册与发现 能够实现负载均衡)

关于Eureka闭源 可以使用zk替代Eureka作为注册中心
zookeeper分布式协调工具 可以实现注册中心 采用zookeeper节点类型?(临时节点)
临时节点和生命周期相关联(当服务连接被断开或者宕机意味着会话会被关闭 那么临时节点就自动会被删除)
zk作为注册中心缺点为 没有服务自我保护机制 就是无法排除连接断开原因是服务宕机还是网络不通

Eureka保证AP zookeeper保证CP  是因为服务保护机制
Zookeeper是保证CP
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
Eureka是保证AP
Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： 
1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 
3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中
因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

Ribbon 是SpringCloud(本地)客户端均衡器
CAP
一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）
可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）

Ribbon本地负载均衡器与Nginx负载均衡器有什么区别?
Ribbon本地负载均衡,原理:在调用接口的时候,会在Eureka注册中心上获取注册服务信息列表,获取到之后,缓存在JVM本地.让你使用本地实现rpc远程调用技术进行调用,即是客户端实现负载均衡
Nginx是服务器负载均衡,客户端所有请求都会交给Nginx,然后由Nginx实现转发请求.即负载均衡由服务端实现
应用场景:
    Ribbon本地负载均衡器适合在微服务rpc远程调用,比如dubbo SpringCloud
    Nginx服务器负载均衡 适合于针对于服务器端 比如tomcat jetty


feign客户端调用缺点:应该重构接口信息(重点)

Hystrix服务保护框架,在微服务中Hystrix能够为我们做哪些事情?
    断路器 服务降级 服务隔离机制 服务熔断 服务雪崩效应 连环雪崩效应

基于Hystrix解决雪崩效应原理:
    通过服务降级 服务熔断 服务隔离

服务降级:
    在高并发情况下,为了防止用户一直等待,使用服务降级方式(返回一个友好提示直接给客户端,不会去处理请求,调用fallback方法),目的是为了提升用户体验
    (秒杀--当前请求人数过多 请稍后重试  在tomcat中没有线程进行处理客户端请求的时候,不应该让用户一直在转圈等待)
服务熔断:
    服务熔断是为了保护服务,在高并发情况,如果请求达到一定的极限(可以自定义阈值),如果流量超出了设置阈值,自动开启服务保护功能,使用服务降级的方式返回友好提示title.
    服务熔断和服务降级一起使用
服务隔离:
    线程池和信号量隔离.
    线程池隔离:每个服务接口都有自己独立的线程池,每个线程池互不影响,缺点:CPU占用比较高(不是所有的接口都去采用线程池隔离,是核心关键接口设置线程池隔离)

Hystrix有两种搭建方式
    接口方式  注解方式@HystrixCommand
    正常的业务逻辑是正常执行 但是在规定时间不能return就会走降级方法

SpringCloud Config 分布式配置中心
为什么要使用分布式配置中心?
    产生的背景:在微服务如果使用传统的方式管理配置文件,配置文件管理器非常复杂.
    如果生产环境配置文件,可能需要发生改变的时候,重新打war,重新读取配置信息在JVM内存中.
什么是分布式配置中心
    在微服务当中使用同一服务器管理所有服务配置文件信息,能够实现后台可管理,当服务器正在运行的时候,如果配置文件需要发生改变,可以实现不需要重启服务器实时更改配置文件信息

热部署 其实底层还是会重启服务器 不适合用于生产环境 只适合本地开发测试.


分布式配置中心框架
    apollo 携程写分布式配置中心 有图形界面可以管理配置文件信息 配置信息存放在数据库中

SpringCloud 没有后台可管理分布式配置中心,配置文件存放在版本控制器里面. GIT SVN 

使用zookeeper实现分布式配置中心,持久节点+事件通知.

1.SpringCloud Config 分布式配置中心原理
2.首先需要分析分布式配置中心需要哪些组件?
    2.1web管理系统 -- 后台可以使用图形界面管理配置文件 SpringCloud Config 没有图形化管理配置文件
    2.2存放分布式配置文件信息 -- 使用版本控制器存放配置文件信息 使用git环境
    2.3.ConfigServer缓存配置文件服务器(临时缓存存放) 
    2.4ConfigClient 读取ConfigServer配置文件信息

为什么要设计一层ConfigServer?
    目的缓存git上配置文件信息

1.搭建GIT环境目的:持久化存储配置文件信息
GIT环境上文件夹以项目进行区分
2.公司项目中环境上如何区分
    dev 开发环境
    sit 测试环境
    pre 预发布环境
    prd 准生产环境
演练两个环境 sit环境和prd环境
3.在git环境上如何存放配置文件


默认情况下不能及时的获取实时变更的配置文件信息
SpringCloud分布式配置中心可以采用手动刷新或者自动刷新
手动刷新 -- 需要人工调用接口 读取最新配置文件(监控中心)
自动刷新 -- 消息总线进行实时通知 -- SpringBus

手动刷新 自动刷新 不需要重启服务器
需要依赖调用actuator/refresh接口刷新
不建议使用自动刷新功能 


网关API(接口) GateWay(网关) --接口网关注意:接口没有界面

接口在什么背景下产生? 在面向服务架构和微服务背景下产生 目的都是为了解耦
    rpc远程调用中产生

接口如何分类?
    开放接口 -- 其他机构合作伙伴进行调用(必须在外网访问) 蚂蚁开放平台 微信公众号开发 需要通过appId+appsocet 使用AccessToken进行通讯
        对接支付开发 微信开发  目的可以授权一些接口权限OAuth2.0协议方式 第三方联合登录
    内部接口 -- 一般只能在局域网中进行访问,服务与服务调用之间关系都在同一个微服务系统中.目的是为了保证安全问题.

考虑:
    接口权限(开放接口|内部接口)
    考虑幂等性问题
    安全性(https)
    防止篡改数据(验证签名 验签)
    使用网关拦截接口实现黑名单 白名单
    接口实现https协议+json是为了实现跨平台
    考虑高并发 对接口服务实现服务保护 服务降级 熔断 隔离等等
    最后使用统一的API管理平台 swagger

网关概念:相当于客户端请求统一先请求到网关服务器上,再由网关服务器进行转发到实际服务器地址上.类似于Nginx
网关的作用:网关可以拦截客户端所有请求,对该请求进行权限控制,负载均衡,日志管理,接口调用监控等

过滤器与网关的区别?
    过滤器是拦截单个tomcat服务器进行拦截请求.
    网关是拦截整个微服务所有请求.

网关分为内网网关和外网网关.

Nginx与Zuul有什么区别?
    Nginx是采用服务器负载均衡进行转发
    Zuul依赖Ribbon和eureka实现本地负载均衡转发
    相对来说Nginx功能比Zuul功能更加强大，能够整合其他语言比如lua脚本实现强大的功能，同时Nginx可以更好的抗高并发，Zuul网关适用于请求过滤和拦截等。


Nginx+zuul实现网关集群
Nginx 与zuul的区别
    微服务网关可以针对于整个微服务实现统一请求拦截 网关基本上都采用自己熟悉的语言开发.
    网关对度所有服务会话进行拦截
    网关安全控制 统一异常处理 xxs sql注入
    权限控制 黑名单 杯名单 性能监控 日志打印
    


SpringBoot Swagger API接口文档
swagger 不要写@RequestMapping注解
类似的版本apiDoc
在微服务中Swagger是每个服务进行集成.
如何将整个微服务中Swagger进行合成?同一个服务器上
    使用Zuul+swagger实现管理整个微服务API文档
    使用Nginx+swagger以项目不同区分跳转不同的接口文档
SpringBoot支持对Swagger管理,只需要zuul网关添加对应服务Swagger文档即可.

传统的RPC远程调用有什么缺点?缺少服务治理,当服务比较多情况下的时候,URL地址管理成本增加
Dubbo解决服务治理问题,核心技术通过注册中心 使用服务治理解决每个服务与服务之间的依赖关系,可以实现均衡 服务注册于发现 容错等等
SpringCloud和Dubbo都属于Rpc远程调用框架 但是SpringCloud功能比Dubbo更强大

dubbo调用流程
0.服务容器负责启动，加载，运行服务提供者。 
1.服务提供者在启动时，向注册中心注册自己提供的服务。 
2.服务消费者在启动时，向注册中心订阅自己所需的服务。 
3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 
4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 
5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

dubbo角色区分:
1.Provider: 暴露服务的服务提供方（生产者）。 
2.Consumer: 调用远程服务的服务消费方（消费者）。 
3.Registry: 服务注册与发现的注册中心。 
4.Monitor: 统计服务的调用次数和调用时间的监控中

Dubbo优缺点
优点:
①透明化的远程方法调用 
  像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。
②软负载均衡及容错机制 
  可在内网替代nginx lvs等硬件负载均衡器。
③服务注册中心自动注册 & 配置管理 
 不需要写死服务提供者地址，注册中心基于接口名自动查询提供者ip。 
使用类似zookeeper等分布式协调服务作为服务注册中心，可以将绝大部分项目配置移入zookeeper集群。
④服务接口监控与治理 
-Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能，针对不同应用的不同接口，可以进行 多版本，多协议，多注册中心管理。
缺点:
只支持Java语言

本地负载均衡轮询算法如何实现 取模算法
请求总数 服务总数 取余

Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、redis等多种协议，但是Dubbo官网是推荐我们使用Dubbo协议的。

1.一个队列里面存放多个消息
2.消息容器中可以存放多个队列
原则:先进先出 后进后出

消息队列在实际应用中常用的使用场景:
    异步处理
    应用解耦
    流量削峰
    消息通讯


JMS通讯模式 默认是自动签收消息,消费者获取到消息之后,不管消费者对该消息处理业务逻辑是否成功,都会默认为已经消费的.
使用手动签收模式,消息中间件将消息推送给消费者,消费者接收到消息之后,必须是手动发送命令告诉给消息中间件已经消费成功.
以事务形式发送或者接收,以事务的形式生产数据,必须以事务的形式消费数据.


rabbitmq交换机的作用
生产者发送消息不会向传统方式直接将消息投递到队列中,而是先将消息投递到交换机中,在由交换机转发都具体的队列,队列再将消息以推送或者拉取的方式给消费者进行消费
交换机的作用根据具体的路由策略分发到不同的队列中,交换机有4种类型
Direct exchange(直连交换机) 是根据消息携带的路由键(Routing key)将消息投递给对应的队列里
Fanout exchange(扇形交换机) 将消息路由给绑定到它身上的所有队列
Topic exchange(主题交换机) 队列通过路由键绑定到交换机上,交换机根据消息里的路由值,将消息路由给一个或多个绑定队列
Header exchange(头交换机) 类似主题交换机,但是头交换机使用多个消息属性来代替路由键简历路由规则.通过判断消息头的值能否与指定的绑定相匹配来确立路由规则

RabbitMQ发布与订阅的实现原理 


如果RabbitMQ宕机,消息是否会丢失?
    支持消息持久化机制

未遵循JMS规范,只提供了发布订阅模式
kafka优点:
    高吞吐量,低延迟,kafka每秒可以处理几十万条消息,它的延迟最低只有几毫秒.
    每个topic可以分为多个partition consumer group对partition进行consumer操作
    -可扩展 kafka集群支持热扩展
    -持久性 可靠性 消息被持久化到本地磁盘,并且支持数据备份防止数据丢失
    -容错性 允许集群中节点失败(若副本数量为n,则允许n-1个节点失败)
    -高斌发 支持数千个客户端同时读写
依赖zk,可动态扩展节点.高性能,高吞吐量,无限扩容,消息可指定追溯

kafka使用场景
- 日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。
- 消息系统：解耦和生产者和消费者、缓存消息等。
- 用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。
- 运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
- 流式处理：比如spark streaming和storm
- 事件源

kafka相关名称
Broker：Kafka节点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群
Topic：一类消息，消息存放的目录即主题，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发
massage： Kafka中最基本的传递对象。
Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列
Segment：partition物理上由多个segment组成，每个Segment存着message信息
Producer : 生产者，生产message发送到topic
Consumer : 消费者，订阅topic并消费message, consumer作为一个线程来消费
Consumer Group：消费者组，一个Consumer Group包含多个consumer
Offset：偏移量，理解为消息partition中的索引即可

kafka存储策略
1）kafka以topic来进行消息管理，每个topic包含多个partition，每个partition对应一个逻辑log，有多个segment组成。
2）每个segment中存储多条消息（见下图），消息id由其逻辑位置决定，即从消息id可直接定位到消息的存储位置，避免id到位置的额外映射。
3）每个part在内存中对应一个index，记录每个segment中的第一条消息偏移。
4）发布者发到某个topic的消息会被均匀的分布到多个partition上（或根据用户指定的路由规则进行分布），broker收到发布消息往对应partition的最后一个segment上添加该消息，当某个segment上的消息条数达到配置值或消息发布时间超过阈值时，segment上的消息会被flush到磁盘，只有flush到磁盘上的消息订阅者才能订阅到，segment达到一定的大小后将不会再往该segment写数据，broker会创建新的segment。

如何实现不重启服务器自动刷新?
    1.手动通知刷新
    2.消息总线bus通知整个微服务刷新

SpringCloud消息驱动原理:
    通过定义绑定器作为中间层，实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通过，是的应用程序不需要再考虑各种不同的消息中间件的实现。当需要升级消息中间件，或者是更换其他消息中间件产品时，我们需要做的就是更换对应的Binder绑定器而不需要修改任何应用逻辑 。
SpringCloud核心概念:
    Source: 当需要发送消息时，我们就需要通过Source，Source将会把我们所要发送的消息(POJO对象)进行序列化（默认转换成JSON格式字符串），然后将这些数据发送到Channel中；
    Sink: 当我们需要监听消息时就需要通过Sink来，Sink负责从消息通道中获取消息，并将消息反序列化成消息对象(POJO对象)，然后交给具体的消息监听处理进行业务处理；
    Channel: 消息通道是Stream的抽象之一。通常我们向消息中间件发送消息或者监听消息时需要指定主题（Topic）／消息队列名称，但这样一旦我们需要变更主题名称的时候需要修改消息发送或者消息监听的代码，但是通过Channel抽象，我们的业务代码只需要对Channel就可以了，具体这个Channel对应的是那个主题，就可以在配置文件中来指定，这样当主题变更的时候我们就不用对代码做任何修改，从而实现了与具体消息中间件的解耦；
    Binder: Stream中另外一个抽象层。通过不同的Binder可以实现与不同消息中间件的整合，比如上面的示例我们所使用的就是针对Kafka的Binder，通过Binder提供统一的消息收发接口，从而使得我们可以根据实际需要部署不同的消息中间件，或者根据实际生产中所部署的消息中间件来调整我们的配置。









