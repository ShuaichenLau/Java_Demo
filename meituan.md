ArrayList 和 Vector 的区别。
    ArrayList在底层数组不够用时候会在原来的基础上扩展0.5倍,Vector是扩展1倍
    Vector是线程安全的,Arraylist是非线程安全.
    比如底层实现的add方法 remove方法 get方法 Vevtor都有synchronized关键字来保证线程安全,所以Vector在单线程环境效率要差.

============================================================================================================================================
说说 ArrayList,Vector, LinkedList 的存储性能和特性。
    ArrayList和Vector底层实现都是一样的,都是使用数据方式存储数据,它们允许直接按照序号索引元素,但是在update数组等需要内存操作,所以索引数据块而update慢
    LinkedList使用双向链表实现存储(将内存中零散的内存单元通过附加的引用关联起来,形成一个可以按序号索引的线性结构.但是这种链表存储方式与数组的连续存储方式相比,内存利用率更高),按序号索引数据需要进行前向或后向遍历,只需要记录本项的前后项即可,所以update比较快.
    Vector是线程安全,ArrayList和LinkedList是非线程安全,在多线程问题可以通过工具类Collections中的synchronizedList方法来实现线程安全.(装饰模式)

============================================================================================================================================
快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？
快速失败:
    在用迭代器遍历一个集合对象时候,如果遍历过程中对集合对象的内容进行update,则会抛出Concurrent Modification Exception.
    原理:迭代器在遍历时候直接访问集合中的内容,并且在遍历过程中使用modCount变量.集合在被遍历期间如果内容发生变化,就会改变modCount的值.每当迭代器使用hashNext()/next()遍历下一个元素之前,都会检测modCount变量是否为expectedmodCount值,是的话就返回遍历,否则抛出异常终止遍历.
        注意:这里异常的抛出条件是指检测到modCount!=expectmodCount这个条件.如果集合发生变化时修改modCount值刚好又设置了expectedmodCount值,则异常不会抛出.
        场景:java.util包下的集合类都是快速失败的,不能再多线程下发生并发修改(迭代过程中被修改).
安全失败:
    采用安全失败机制的集合容器,在遍历时不是直接在集合内容上访问的,而是先复制原有集合内容,在拷贝的集合上进行遍历.
    原理:由于迭代时是对原集合的拷贝进行遍历,所以在遍历过程中对原集合所作的修改并不能被迭代器检测到,所以不会被触发Concurrent Modification Exception.
        缺点:基于副本内容的优点是避免了Concurrent Modification Exception,但同样迭代器并不能访问到修改后的内容.
        即迭代器遍历的是开始遍历的那一刻拿到的副本(集合拷贝),在遍历期间原集合发生的修改迭代器是不知道的.
        场景:java.util.concurrent包下的集合都是安全失败,可以在多线程下并发使用,并发修改.

============================================================================================================================================
hashMap 的数据结构。hashMap 的工作原理是什么?
    hashMap基于hashing原理,通过put()和get()方法储存和获取对象.当我们将键值对传递给put()方法时候,它调用键对象的hashCode方法来计算hashCode,然后找到卡槽bucket位置来存储值对象.获取到对象以后通过键对象的equal()方法找到正确的键值对,然后返回值对象.HashMap使用LinkedList来解决碰撞问题,当发生碰撞之后,对象将会存储在linkedList的下一个节点中.HashMap在每个linkedList节点中存储键值对对象.
    hashMap底层主要是基于哈希数组+链表来实现的,通过计算散列码来决定存储的位置.HashMap中主要是通过key的hashCode来计算hash值,hashCode一样,hash值也就一样,但是也会有不同的对象计算出来的hash值是相同的.这是hash冲突问题.hashMap底层就是通过链表来解决hash冲突.
    hashMap构造函数有两个参数:初始容量和加载因子.可以直接影响HashMap性能的参数.初始容量表示创建哈希表时的容量,加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度,是用来衡量一个散列表空间的使用程度.负载因子越来表示散列表的装填程度越高,反之越小.
    如果负载因子越大,对空间利用更充分,但是查找效率会降低;负载因子越小,空间利用率不高.这里hashMap默认负载因子是0.75.当哈希条目超过加载因子与当前容量的乘积时,会调用rehash方法将容量翻倍.

============================================================================================================================================
hashMap 什么时候进行扩容呢？
    hashMap默认负载因子是0.75.当哈希条目超过加载因子与当前容量的乘积时,会调用rehash方法将容量翻倍.

============================================================================================================================================
List、Map、Set 三个接口，存取元素时，各有什么特点？
    List Set都是单列元素的集合,它们都有一个共同的父类Collection.
    Set里面不允许存储重复的元素,add方法有一个boolean的返回值.当集合含有某元素equal相等的元素,此时add无法加入,返回false,反之返回true,成功加入集合.
    只能通过Iterator接口获取所有元素,再逐一遍历元素.
    
    List表示有先后顺序的集合,调用add方法,默认按照添加的顺序排序,也可以插队,通过add(int index, Object obj)方法来完成该元素在这个集合的存放位置.
    可以通过Iterator接口获取所有元素,逐一遍历对象,或者foreach,或者get(int index)方式来获取元素

    Map是双列的集合,用put方法来做存储,每次存储要存储一对key/value形式,不能存储重复的key,重复规则也是通过equal来比较.
    get方法通过key获得相应的value.也可以获得所有的value集合,还可以获得所有的value集合.
    List以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。

============================================================================================================================================
Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?
    equal(), ==在引用类型对象中是比较堆内存地址 equal是比较值对象,是属于内容比较. 在int double基本类型等等 应用双等号==来比较 这是比较它们的值.
============================================================================================================================================

两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?
    在Java语言定义总,两个相同的对象hashCode一定相同,hashCode相等对象未必相等.
============================================================================================================================================

heap 和 stack 有什么区别。
    堆:队列优先,先进先出
    栈:先进后出
    栈是暂存空间,主要用于内部计算.当函数被调用时,栈队列上有一块区域会被分配出来用作存储局部变量和数据.当函数返回时,这块区域会被释放.由于栈的先进后出特性,所以最近被使用的区域会最先被释放,最后被使用的区域最后释放,所以栈的内存回收不需要关心.
    堆是动态分配,有很强的灵活性,但是堆的速度要比栈慢.因为堆的分配是由程序运行时候调用系统完成的,而栈是线程建立时会自动为系统级线程分配栈stack.
============================================================================================================================================

Java 集合类框架的基本接口有哪些？
    collection Map
============================================================================================================================================

HashSet 和 TreeSet 有什么区别？HashSet 的底层实现是什么?
    HashSet底层是由哈希表实现,TreeSet底层是由红黑树实现.如果需要在TreeSet中插入对象,需要实现Comparable接口,为其指定比较排序策略.
    都不允许重复保存对象.
============================================================================================================================================

LinkedHashMap 的实现原理?
    linkedHashMap是hash表和链表的实现,并且依靠着双向链表保证迭代顺序是插入的顺序.
    linkedHashMap继承hashMap并且实现Map接口,put函数在linkedHashMap中为重新实现,只是实现了afterNodeAccess和afterNodeInsertion两个回调函数.get函数则重新实现并加入了afterNodeAccess来保证访问顺序.accessOrder模式下,false基于插入顺序,true为访问顺序.只要执行get或者put操作时就会产生structural modification.
    linkedHashMap是基于hashMap实现,其他操作基本上都是为了维护那个具有访问顺序的双向链表.
============================================================================================================================================

为什么集合类没有实现 Cloneable 和 Serializable 接口？
    克隆或者序列化的语义和含义是跟具体的实现相关的.因此应该由集合类的具体实现类来决定如何被克隆或者序列化.
        克隆指的是A对象里的属性值克隆到B对象,而不是对象引用的复制
        实现序列化的作用是:
            a.将对象的状态保存在存储媒体中以便以后重写创建出完全相同的副本.
            b.实现序列化接口作用是可以把对象存在字节流,然后可以恢复.如果实现对象在网络中(分布式应用中)传输就需要实现序列化.
============================================================================================================================================

什么是迭代器 (Iterator)？
    迭代器是一种设计模式,它是一个对象,可以遍历并选择序列中的对象,只能单向移动.
    使用方法iteration()要求容器返回一个iteration.调用next()方法时,返回序列的第一个元素.iteration()方法适java.lang.Iterable接口,被Collection继承.
    使用next()获取序列中的下一个元素
    使用hashNext()检查序列中是否还要元素
    使用remove()将迭代器新返回的元素删除.
    另外也有为List设计的ListIterator具有更多的功能,它可以从两个方向遍历List,也可以从List中插入和删除元素.
============================================================================================================================================

Iterator 和 ListIterator 的区别是什么？
    这两个都是迭代器,当需要对集合中元素进行遍历不需要干涉其遍历过程中时,这两种迭代器都可以使用.
    使用范围不同,Iterator可以应用于所有的集合,Set List Map这些集合的子类型.而ListIterator只能用于List及其子类型.
    ListItrator有add方法,可以向list中添加对象.
    都有hashNext()方法和next()方法,可以实现顺序向后遍历,但是ListIterator有hasPrevious()和previous()方法,可以实现逆向(顺序向前)遍历.
    ListItrator可以定位当前索引的位置,nextIndex()和previousIndex()可以实现.
    都可以实现删除操作,但是ListItrator可以实现对象的修改,set().Iteration只能遍历,不能修改.
============================================================================================================================================

数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？
    Array是数组,声明数组时候就要初始化并且确定长度,长度不可变.并且只能存储同一类型的数据.
    ArrayList是集合类,需要先声明,再添加数据,长度是根据元素多少而改变.ArrayList可以存放不同类型的数据,在存储基本类型数据的时候要使用基本数据类型的包装类.
    如果能确定长度并且数据类型一致可以用Array数组,其他情况使用ArrayList集合类.
============================================================================================================================================

Java 集合类框架的最佳实践有哪些？
    图片
============================================================================================================================================

Comparable 和 Comparator 接口是干什么的？列出它们的区别
    Comparable 和 Comparator都是用来实现集合中元素的比较排序的.只是Comparable是在集合内部定义的方法实现的排序,Comparator是在集合外部实现的排序.所以想实现排序就需要在集合外定义Comparator接口的方法或者在集合内实现Comparable接口的方法.
    既然它们都是能实现比较排序功能,但是在自己写一个自定义类加入list容器中后能够排序,可以实现Comparable接口,在用Collections类的sort方法排序.如果不指定Comparator那就默认按照自然排序,这里的自然排序是由Comparable接口设定的排序方式.而Comparator是一个专用的比较器,当这个对象不支持自比较或者自比较函数不能满足需求时,可以写一个比较器来完成两个对象之间的比较.这Comparator是策略模式,不改变对象自身,而用一个策略对象来改变它的行为.
    比如说对整数采用绝对值大小来排序,integer是不符合要求的,我不需要去改Integer类去改变它的排序(实际上也不能这么做),只要使用Comparator接口的对象来实现控制排序.
============================================================================================================================================

Collection 和 Collections 的区别。
    Collection是集合类的上级接口,子接口主要有Set和List
    Collections是针对集合类的提供工具方法,一系列静态方法,实现对各种集合的搜索排序线程安全化等操作.
============================================================================================================================================


JVM与调优21题
1.Java 类加载过程？
    加载,验证,准备,解析,初始化,使用,卸载.
    加载:查找和导入类或者接口的二进制数据
    链接:执行校验,准备和解析步骤.
    校验:检查导入类或者接口的二进制数据的正确性
    准备:给类的静态变量分配并初始化存储空间
    解析:将符号引用转正直接引用
    初始化:激活类的静态变量,初始化Java代码和静态Java代码块.
============================================================================================================================================

2.描述一下 JVM 加载 Class 文件的原理机制?
    Java中所有的类,都需要由类加载器装载到JVM内存中才能运行.类加载器本身也是class类,而它的工作就是把class文件从硬盘读取到内存中.
    类装载方式有两种:隐式装载 显式装载
        1.隐式装载:程序在运行过程中当碰到通过new等方式生成对象,隐式调用类装载器加载对应的类到JVM中.
        2.显式装载:通过class.forName()等方法,显式加载需要的类
    隐式加载与显式加载的区别:两者本质是否一样?
        Java类的加载是动态的,并不会一次将所有的类全部加载后再运行,而是保证程序运行的基类完全加载到jvm中,至于其他类,则在需要的时候才会加载.(懒加载模式)为了节省内存开销.
    Java类加载器有三个,对应Java的三种类(Java中的类大致分为3种,系统类,扩展类,由程序员自定义的类)
        BoostrapLoader 负责加载系统类(指内置类)
            --ExtClassLoader 负责加载扩展类(就是继承类和实现类)
                --APPClassLoader  负载加载应用类(程序员自定义的类)
    三个加载器各自完成自己的工作,为了解决协调工作的问题,Java采用委托模型机制.  (双亲委托模型机制)
    委托模型机制的工作原理:当类加载器需要加载类的时候,先请示parent加载器在其搜索路径载入,如果找不到,才在自己的搜索路径搜索该类.采用加载器层次上自顶而下的搜索,因为加载器必须保证基类的加载.
    获取类加载器:
        ClassLoader loader = ClassName.class.getClassLoader();
        ClassLoader ParentLoader = loader.getParent();
    Java在逻辑上并不存在BootstrapLoader的实体,因为它是由c++实现,所以打印内容为null.
    a.装载:查找和导入class文件.
    b.连接:
        检查:检查载入的class文件数据的正确性
        准备:为类的静态变量分配存储空间
        解析:将符号引用转换成直接引用(可选步骤)
    c.初始化:初始化静态变量,静态代码块
        这样的过程在程序调用类的静态成员时会开始执行.所以静态main()才会成为一般程序的入口方法.类的构造器也会引发该动作.
============================================================================================================================================

3.Java 内存分配。
    a.栈:存放基本数据类型,对象的引用.注意对象的引用是放在栈中,而对象本身是放在堆中(new出来的对象)或者常量池中(字符串常量对象)
    b.堆:存放所有new出来的对象
    c.常量池:存放字符串敞亮和基本数据类型的敞亮(public static final)
    d.方法区:存放静态常量等等(static)

    基础的数据类型直接存放在栈中,static final的存放在常量池当中
    局部变量(包括形参)分配在栈中,随着方法帧消失而消失
    成员变量存储在堆中,有GC负责回收
============================================================================================================================================

4.GC 是什么? 为什么要有 GC？
    垃圾收集器.内存处理是开发最容易出现的问题,忘记回收或者错误内存回收都会导致程序或者系统不稳定甚至崩溃
    Java提供GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的,Java语言没有提供释放已分配内存的显式操作.
============================================================================================================================================

5.简述 Java 垃圾回收机制
    在系统运行过程中总会产生一些废弃或者无用的对象在内存里.但是我们内存空间是有限的,如果我们不能及时清理垃圾对象回收内存的话,内存就会被耗尽.这样的话就会导致我们的程序崩溃.
============================================================================================================================================

6.如何判断一个对象是否存活？（或者 GC 对象的判定方法）
    在堆里面存放着Java世界中几乎所有的对象实例,垃圾收集器在堆内存进行回收前,都会判断这些对象.
    判断对象是否还存活,也就是确定对象已经不可能有任何途径使用的对象,这里有两种算法:引用计数算法,可达性分析算法.
    引用计数算法的原理就是给对象添加一个引用计数器,每当有一个地方引用它时,计数器值就+1,当引用失效时,就-1.当计数器值为0时就表示这个对象不可能再被使用.当然这个计数器也有一个问题,就是很难解决相互引用带来的缺陷.
    可达性算法是通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GcRoots没有任何引用链相连时,则证明对象是不可用的.
============================================================================================================================================

7.垃圾回收的优点和原理。并考虑 2 种回收机制？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
    Java中最大的优点就是引入了垃圾回收机制,这样Java开发在编程时不再需要考虑内存管理.由于有个垃圾回收机制,Java中对象再有"作用域"的概念,只有对象的引用才有"作用域".垃圾回收可以有效防止内存泄漏,有效使用可以使用的内存.垃圾回收器通常是作为一个单独的低级别的线程运行,不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收,程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收.回收机制有分代复制垃圾税后和标记垃圾回收,增量垃圾回收.
============================================================================================================================================

8.Java 中会存在内存泄漏吗，请简单描述
    理论上有Java因为有内存回收机制是不会存在内存泄漏问题,但是在实际开发过程中可能会存在一些无用但可达的对象,这些对象就不能被GC回收,因此就会出现内存泄漏问题.
============================================================================================================================================

10.深拷贝和浅拷贝。
    浅拷贝是复制对象的所有变量都含有与原来对象相同的值,而所有的对其他对象的引用仍然指向原对象.即对象的浅拷贝会对原对象进行拷贝,但不会复制原对象里面的对象."里面的对象"会在原对象和它的副本之间存在共享关系.
    浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.
    深拷贝是一个整个独立的对象副本,深拷贝会拷贝所有的属性,也包含"里面的对象".属于完整拷贝.
    深拷贝相对于浅拷贝来说速度慢开销大.
============================================================================================================================================

11.System.gc() 和 Runtime.gc() 会做什么事情？
    通知垃圾回收器回收无用对象释放内存.
    但是JVM可以屏蔽掉显示的垃圾回收调用.
============================================================================================================================================

12.finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？
    当GC要宣告一个对象死亡时,至少要经过两次标记过程:如果对象在进行可达性分析后发现没有和GCRoots相连接的引用链,就会被第一次标记,并且判断是否执行finalize()方法,如果对象覆盖finalize()方法并且未被虚拟机调用过,那么这个对象会被防止FQueue队列中,并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer()方法,但不承诺等待其运行结束.
    finalization的目的:对象逃脱死亡的最后一次机会.(只要重新与引用链上的任何一个对象建立关联即可.)但是不建议使用,运行代价比较大,不确定比较大,且无法保证各个对象的调用顺序.可用try-finally或者其他替代.
============================================================================================================================================

13.如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？
    不会立即释放对象占用的内存.如果对象引用置为NULL,只是断开了当前线程栈帧中对该对象的引用关系,而垃圾收集器是运行在后台的线程,贞阳侯当用户线程运行到安全点或者安全区域才会扫描对象引用关系,扫描到对象没有被引用会被标记,这时候仍然不会立即释放该对象的内存,因为有些对象是可以恢复的(内存逃逸).只有确定了该对象不可恢复之后才会被回收.
============================================================================================================================================

14.什么是分布式垃圾回收（DGC）？它是如何工作的？
    RMI子系统实现基于引用计数的"分布式垃圾回收"DGC,以便为远程服务器对象提供自动内存管理设施.
    当客户机创建(序列化)远程引用时,会在服务端DGC上调用dirty().当客户机完成远程引用后,就会调用对应的clean()方法.
    针对远程对象的引用由持有该引用的客户机租用一段时间.租期从收到dirty()调用开始.
    在此类租约到期之前,客户机必须通过对远程引用额外调用dirty()来更新租约.如果客户机不再租约到期前进行续签,那么分布式垃圾收集器会假设客户机不再引用远程对象.
============================================================================================================================================

15.串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
    串行收集器:整个扫描和复制过程采用单线程的方式.
    吞吐量收集器:也叫作并行收集器,采用多线程的方式来完成垃圾的收集,适合于吞吐量要求较高的场合.
============================================================================================================================================

16.在 Java 中，对象什么时候可以被垃圾回收？
    当一个对象到GCRoots不可达时,在下一个垃圾回收周期中就会尝试回收这个对象,如果这个对象重写了finalize()方法,并在这个方法中成功自救(将自身赋予某个引用),那么这个对象不会被回收.但如果这个对象没有重写finalize()方法或者已经执行过这个方法,也会自救失败,该对象会被回收.
============================================================================================================================================

17.简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。
    当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 MinorGC 这样可以加快老年代的回收速度。
============================================================================================================================================

18.JVM 的永久代中会发生垃圾回收么？
    永久代没有自己的回收器,是和老年代一起回收的.是老年代触发FullGC的时候捎带回收永久代的内存.
    永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收,当没有对象引用一个常量的时候,该常量可以被回收.而类型的卸载更加负载.
    必须满足3点:该类型的所有实例都被回收,该类型的ClassLoader被回收了,该类型的对应的java.lang.class没有在任何地方被引用,在任何地方都无法通过反射来实例化一个对象.
============================================================================================================================================

19.Java 中垃圾收集的方法有哪些？
    串行回收 并行回收
============================================================================================================================================

20.什么是类加载器，类加载器有哪些？
    classLoader 有BoostrapLoader  ExtClassLoader  APPClassLoader
============================================================================================================================================

21.类加载器双亲委派模型机制？
    JVM中加载类机制采用的双亲委派模型机制.在这模型里子类加载器收到的加载请求,不会先去处理,而是先把请求委派给父类加载器去处理,当父类加载器处理不了时再返回给子类加载器加载;这样做保证类加载器安全,使用双亲委派模型来组织类加载器之间的关系,能够使类的加载也具有层次关系,这样能够保证核心基础的Java类被根加载器加载,而不会去加载用户自定义的和基础类库相同名字的类,从而保证系统的安全有序.
============================================================================================================================================


并发编程28题
Synchronized 用过吗，其原理是什么？
    作用a.确保线程互斥的访问同步代码  作用b.保证共享变量的修改能够及时可见  作用c.有效解决重排序问题
    用法a.修饰普通方法  用法b.修饰静态方法  用法c.修饰代码块
    每个对象都有一个监视锁,当monitor被占用时就会处于锁定状态,线程执行monitorenter指令时尝试获取monitor的所有权
        a.如果monitor的进入数为0,则该线程进入monitor,然后将进入数设置为1,该线程即为monitor的所有者
        b.如果线程已经占有monitor,只是重新进入,则进入monitor的进入数加1
        c.如果其他线程已经占用了monitor,则该线程进入阻塞状态,知道monitor的进入数为0,再重新尝试获取monitor的所有权
    执行monitorexit线程必须是objectref所对应的monitor的所有者
    指令执行时,monitor的进入减1,如果减1后进入数为0,那线程退出monitor,不再是这个monitor的所有者.

============================================================================================================================================

23.你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

24.什么是可重入性，为什么说 Synchronized 是可重入锁？

25.JVM 对 Java 的原生锁做了哪些优化？

26.为什么说 Synchronized 是非公平锁？

27.什么是锁消除和锁粗化？

28.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？

    cas自旋锁

29.乐观锁一定就是好的吗？
    乐观锁在一定程度上可以避免线程上下文切换带来的性能损失
    乐观锁适用于多读的应用类型,这样可以提高吞吐量.
    

30.跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

31.那么请谈谈 AQS 框架是怎么回事儿？

32.请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。

33.ReentrantLock 是如何实现可重入性的？

34.除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？

35.请谈谈 ReadWriteLock 和 StampedLock。

36.如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。

37.CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？

Java 线程池相关问题
Java 中的线程池是如何实现的？

创建线程池的几个核心构造参数？
    corePoolSize:核心线程数
    maximumPoolSize:最大线程数
    keepAliveTime:空闲线程保留时间
    TimeUnit:空闲线程保留时间单位
    BlockingQueue<Runnable>:阻塞队列
    ThreadFactory:线程工厂
    RejectedExecutionHandler:队列已满,而且任务量大于最大线程的异常处理策略
============================================================================================================================================


线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？

既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同

如何在 Java 线程池中提交线程？

什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？

请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？

既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？

请对比下 volatile 对比 Synchronized 的异同。

请谈谈 ThreadLocal 是怎么解决并发安全的？

很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？



spring 25题



什么是 Spring 框架？Spring 框架有哪些主要模块？

使用 Spring 框架能带来哪些好处？

什么是控制反转(IOC)？什么是依赖注入？

请解释下 Spring 框架中的 IoC？

BeanFactory 和 ApplicationContext 有什么区别？

Spring 有几种配置方式？

如何用基于 XML 配置的方式配置 Spring？

如何用基于 Java 配置的方式配置 Spring？

怎样用注解的方式配置 Spring？

请解释 Spring Bean 的生命周期？

Spring Bean 的作用域之间有什么区别？

什么是 Spring inner beans？

Spring 框架中的单例 Beans 是线程安全的么？

请举例说明如何在 Spring 中注入一个 Java Collection？

如何向 Spring Bean 中注入一个 Java.util.Properties？

请解释 Spring Bean 的自动装配？

请解释自动装配模式的区别？

如何开启基于注解的自动装配？

请举例解释@Required 注解？

请举例解释@Autowired 注解？

请举例说明@Qualifier 注解？

构造方法注入和设值注入有什么区别？

Spring 框架中有哪些不同类型的事件？

FileSystemResource 和 ClassPathResource 有何区别？

Spring 框架中都用到了哪些设计模式？



设计模式 10题



请列举出在 JDK 中几个常用的设计模式？

什么是设计模式？你是否在你的代码里面使用过任何设计模式？

Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式

在 Java 中，什么叫观察者设计模式（observer design pattern）？

使用工厂模式最主要的好处是什么？在哪里使用？

举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？

在 Java 中，为什么不允许从静态方法中访问非静态变量？

设计一个 ATM 机，请说出你的设计思路？

在 Java 中，什么时候用重载，什么时候用重写？

举例说明什么情况下会更倾向于使用抽象类而不是接口



springboot 22题



什么是 Spring Boot？

Spring Boot 有哪些优点？

什么是 JavaConfig？

如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？

Spring Boot 中的监视器是什么？

如何在 Spring Boot 中禁用 Actuator 端点安全性？

如何在自定义端口上运行 Spring Boot 应用程序？

什么是 YAML？

如何实现 Spring Boot 应用程序的安全性？

如何集成 Spring Boot 和 ActiveMQ？

如何使用 Spring Boot 实现分页和排序？

什么是 Swagger？你用 Spring Boot 实现了它吗？

什么是 Spring Profiles？

什么是 Spring Batch？

什么是 FreeMarker 模板？

如何使用 Spring Boot 实现异常处理？

您使用了哪些 starter maven 依赖项？

什么是 CSRF 攻击？

什么是 WebSockets？

什么是 AOP？

什么是 Apache Kafka？

我们如何监视所有 Spring Boot 微服务？



Netty10题



BIO、NIO和AIO的区别？

NIO的组成？

Netty的特点？

Netty的线程模型？

TCP 粘包/拆包的原因及解决方法？

了解哪几种序列化协议？

如何选择序列化协议？

Netty的零拷贝实现？

Netty的高性能表现在哪些方面？

NIOEventLoopGroup源码？



Redis 16题

redis有哪些模式?
    哨兵模式 发布订阅模式 redisSession模式
============================================================================================================================================

一个字符串类型的值能存储最大容量是多少?
    512MB
============================================================================================================================================

什么是redis?Reids的特点 (NoSQL)
    redis是一个高性能的key-value数据库.
    redis支持数据持久化,可以将内存中数据保存到磁盘中,重启的时候可以再次加载使用
    redis支持key-value形式的数据库,同时还提供list,set,hash,zset,String等数据类型
    redis支持数据备份,即master-slave模式的数据备份
    redis的所有操作都是原子性的,意思是要么执行成功,要么失败完全不执行.单个操作是原子性.多个操作也支持事务,即原子性.多个操作也支持事务,即原子性.通过MULTI和EXEC指令包起来.
    redis支持publish/subscribe,通知key过期等等特性.
============================================================================================================================================

Redis支持的数据类型
    list,set,hash,zset,String等数据类型
============================================================================================================================================

Redis是单进程单线程的
    完全基于内存操作,数据存在内存中类似于hashMap,hashMap的优势就是查找和操作的时间复杂度都是O(1).
    采用单线程避免不必要的上下文切换和多线程资源竞争.
    使用多路I/O复用,非阻塞IO
    使用底层模型不同,它们之间底层实现方式以及客户端之间的通信应用协议不一样,redis直接自己构建了VM机制.
    redis利用队列技术将并发访问变为串行访问,消除了传统数据库串行控制的开销
    但是使用单线程无法发挥多核CPU的性能,但是可以通过在单机环境搭建多个redis实例来完善.所以在centos环境中我都是搭建docker来实现多redis实例环境
============================================================================================================================================

为什么Redis需要把所有数据放到内存中?
    Redis为了达到最快的读写速度将数据都落在内存上,并且通过异步的方式写到磁盘上.所以Redis具有快速和数据持久化的特征.
    如果不将数据放在内存中,磁盘IO速度会严重影响redis性能.
    可以设置最大使用的内存,则数据已有记录达到内存最大限制后不能继续插入新值.
============================================================================================================================================

Redis锁

读写分离模型

数据分片模型

Redis的回收策略
    volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    no-enviction（驱逐）：禁止驱逐数据
    注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。
    使用策略规则：
        （1）如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
        （2）如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random
============================================================================================================================================

Redis过期键的删除策略?
    a.定时删除:在设置键的过期时间的同时,创建一个定时器timer,让定时器在键的过期时间来临时,立即执行删除操作
    b.惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话就删除该键,相反就返回该键.
    c.定期删除:每个一段时间程序就对数据库进行一次检查,删除里面的过期键.至于要删除多少过期键,以及要检查多少个数据库,由代码算法而决定.
============================================================================================================================================

使用Redis有哪些好处？
    a.速度快,因为数据存在内存中,类似于HashMap,HashMap的优势就是查找和操作的时间复杂度都是O1
    b.支持丰富数据类型,支持string,list,set,hash,zset等
    c.支持事务,操作都是原子性,所谓的原子性就是对数据的更改要么全部执行,要么全部不执行
    d.丰富的特性:可用于缓存,消息,按key设置过期时间,过期后将会自动删除.
============================================================================================================================================

redis相比memcached有哪些优势？
    redis速度要比Memcache要快
    memcache所有的值均是简单的字符串,redis作为其替代者,支持更为丰富的数据类型
    redis可以做数据持久化
============================================================================================================================================

MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据?
    redis内存数据集大小上升到一定大小的时候,就会施行数据淘汰策略.
    redis提供6种数据淘汰策略:
        volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
        volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
        volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
        allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
        allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
        no-enviction（驱逐）：禁止驱逐数据
============================================================================================================================================

Memcache与Redis的区别都有哪些？
    a.Memcache把数据都存储在内存上,断点后消失.数据容量不能超过内存大小 redis有部分数据存储在硬盘上,能保证数据的持久性.
    b.数据支持类型Memcache相对来说比较简单 redis有复杂的数据类型
    c.使用底层模型不同,以及与客户端通信的协议也不同.但是redis构建了自己的vm机制.减少调用底层系统造成的性能损失.(一般的系统调用系统函数,会浪费一定的时间去移动和请求)
============================================================================================================================================

Redis 常见的性能问题都有哪些？如何解决？redis常见性能问题和解决方案
    Master最好不要写内存快照,如果Master写内存快照,save命令调度rdbSave函数,会阻塞主线程的工作,当快照比较大的时候对性能的影响是比较大的,会出现间断性的暂停服务
    如果数据比较重要,某个Slave开启AOF备份数据,策略设置为每秒同步一次
    最好在一个局域网,为了主从复制和连接的稳定性.
    尽量避免在压力很大的主库上增加从节点
    主从复制不要用图状结构,用单项链表结构,或者二叉树结构.这样方便解决单点故障问题,实现Slave对Master的替换.如果Master挂了,可以立刻启用Slave1做Master,其他不变.
============================================================================================================================================

Redis 最适合的场景
    会话缓存(SessionCache)
    全页缓存(FPC)除基本会话token之外,redis还提供FPC平台.回到一致性问题,即使重启了redis实例,因为有磁盘的持久化,用户也不会看到页面加载速度的下降.Magento提供一个插件来使用redis作为全页缓存后端.
    队列:redis在内存存储引擎领域的一大优点是提供list和set操作,这使得redis能作为队列使用的操作.
    排行榜/计数器:redis在内存中对数字进行递增或递减的操作实现.集合(set)和有序集合(Sorted Set)也使得我们在执行这些操作的时候变得非常简单,Redis只是正好提供了这两种数据结构.
    发布/订阅:redis发布/订阅功能.
============================================================================================================================================

Redis的持久化机制
    提供两种RDB和AOF持久化机制
    RDB (redis database) 是指用数据集快照的方式半持久化模式记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件,持久化结束后,用这个临时文件替换上次持久化的文件,达到数据恢复
    优点1.只有1个文件dump.rdb,方便持久化 
    优点2.容灾性好,一个文件可以保存到安全的磁盘 
    优点3.性能最大化,fork子进程来完成写操作,让主进程继续处理命令,所以是IO最大化.使用单独子进程来进行持久化,主进程不会进行任何IO操作,保证了redis的高性能.
    优点4.相对于数据集大时,比AOF启动效率更高
    缺点1. 数据安全性低.RDB是间隔一段时间进行持久化,如果持久化之间redis发生故障,会发生数据丢失.所以这种方式更适合数据要求不高的场景.
    AOF(append-only file)是指所有的命令行记录以redis命令请求协议的格式完全持久化存储保存aof文件.
    优点1:数据安全,aof持久化可以配置appendfsync属性,有always,每进行一次命令操作就记录到aof文件中一次
    优点2:通过append模式写文件,即时中途服务器宕机,可以通过redis-check-aof工具解决数据一致性问题.
    优点3:AOF机制的rewrite模式.AOF文件没被rewrite之前(文件过大时会对命令进行合并重写),可以删除其中的某些命令(比如误操作的flushall).
    缺点1:AOF文件比RDB文件大,且恢复速度慢.
    缺点2:数据集大的时候,比rdb启动效率低.
============================================================================================================================================

怎么理解Redis事务?
    a.事务是一个单独的隔离操作,事务中的所有命令都会被序列化,按顺序执行.事务在执行的过程中不会被其他客户端发送来的命令请求所打断.
    b.事务是一个原子操作,事务中的命令要么全部执行,要么全部都不执行.
============================================================================================================================================



事务的隔离级别
事务的传播机制



怎么判断线程是否空闲和繁忙?
















