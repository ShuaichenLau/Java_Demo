@RestController 和 @Controller的区别
    @RestController是组合注解,是@ResponseBody注解和@Controller注解的组合.

count(1) count(*) count(列名)的区别
    从执行计划来看，count(1)和count(*)的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。
    如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。
    因为count(*),自动会优化指定到那一个字段。所以没必要去count(1)，用count(*)，sql会帮你完成优化的。
    在执行效果上:
        1.count(1)会统计表中所有的记录数 (包含字段为null的记录);
        2.count(字段)会统计该字段在表中出现的次数,忽略字段为null的情况 (不统计字段为null的记录);
        3.count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL;
        4.count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL;
        5.count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    在执行效率上:
        1.列名为主键,count(列名)会比count(1)快;
        2.列名不为主键,count(1)会比count(列名)快;
        3.如果表多个列并且没有主键,则count(1)的执行效率要优于count(*);
        4.如果有主键,则select count(主键)执行效率是最好的;
        5.如果表只有一个字段,则select count(*)执行效率是最好的;

1、equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱
2、当两种不同类型用==比较时，包装器类的需要拆箱， 当同种类型用==比较时，会自动拆箱或者装箱



1 JUC是怎么用的?
    a.线程间通信工具类,Semaphore、CountDownLatch、Future.在写多线程高并发的程序时，结合通信工具和锁把线程编排的符合你的预期执行
    b.锁,JUC提供了某些场景下比synchronized更合适的高级锁出现,包括读写锁 互斥锁等等,多数基于cas这种乐观锁实现,性能要由于synchronized内置锁,而且Condition更灵活可控.
    c.原子包装类
    d.线程安全的集合 基于锁分解、分段锁、CAS等机制性能优良且线程安全的集合类，一般在多线程业务中，只要有共享访问的集合，可能不管三七二十一直接用这些同步集合
    e.线程池工具类
2 用过哪些设计模式?
    单例模式 双重校验锁 Emun枚举
    抽象工厂模式 比如车险 农险 人寿险 等等,它们险种不一样,但是都有一种同样的抽象概念,比如说都有相同的保险起止期,等等这些.把相同的属性抽象成父类,特有的属性为子类特有.
    生产者消费者模式 比如说kafka mq 以及听云产品业务前后端分离架构
3 1.8 JVM有哪些优化
4 1.7 1.8 currentHashMap有什么优化
5 提交事务 事务回滚是怎么弄的
    MySQL事务
    https://www.runoob.com/mysql/mysql-transaction.html
6 分布式事务是怎么做的?
7 redis 热搜排序是怎么做的
8 线程池 线程的创建方式
    线程的创建方式
        a.实现Runnable接口
        b.继承Thread类
        c.实现Callable接口
9 object有哪些方法
10 @SpringBootApplication注解有什么作用
11 mq (这个我说不是很了解  只是写过简单的demo)
12 缓存穿透 雪崩 是怎么解决的
13 redis有哪些应用场景
14 创建对象有哪些方式
15 redis持久化的问题
16 MySQL索引是怎么用的 怎么创建索引 索引原理是什么  SQL的优化 explain
17 MySQL  一二三范式  数据库是怎么设计的
18 SpringIOC  AOP

内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存

内存泄漏 内存溢出
泄漏就是内存申请后，用完没有释放，造成可用内存越来越少。
溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常，严重的，攻击者可以以此获取程序控制权。

数据库事务特性ACID
	A原子性:事务是一个完整的操作.事务的各步操作是不可分的(原子的);要么都执行,要么都不执行
	C一致性:当事务完成时,数据都必须是一致的状态
	I隔离性:对数据进行修改的所有并发事务都是彼此隔离的,这表示事务必须是独立的,不应以任何方式依赖于或影响其他事务
	D持久性:事务完成时,对数据库的修改被永久保持,事务日志能保持事务的永久性.

第一范式:
    保持每列的原子性,每一列都是不可拆分的最小单元.(最小的单元,列都是不可再拆分的)
第二范式:
    满足第一范式,并且表中非主键列不存在对主键的部分依赖(每个表只描述一件事)
第三范式:
    满足第二范式,并且表中的列不存在对非主键列的传递依赖.

redis持久化
    aof append的方式持久化
    rdb 生成快照的方式
save命令
    同步生成快照 同时会阻塞所有来自客户端请求,如果数据较大的话,会导致服务长时间不能响应
bgsave命令
    异步生成快照 同时接收所有来自客户端的请求,通过lastSave命令获取最近一次成功执行快照的时间

表单重复提交问题
    rpc远程调用的时候 网络发生延迟的时候 可能会有重试机制
互联网API接口幂等性设计 ## 如何纯手写一个互联网API接口幂等性框架
保证互联网接口幂等性问题
API接口与RPC远程http协议
API幂等性产生的原因:(接口重复提交的问题) 保证接口唯一性 使用token(令牌)保证临时且唯一(15分钟-120分钟)
分布式session解决方案 使用redis+token
token如何生成 token_时间戳(雪花算法ID)  分布式场景问题

如何保证外网开放接口的安全性
    1.搭建API网关控制接口访问权限
    2.开放平台设计oauth2.0协议(安全认证) QQ认证 第三方联合登录
    3.采用https加密传输协议(使用Nginx配置Https)
    4.API接口数字签名(移动的接口)非对称加密RSA 防止抓包分析修改数据
    5.基于令牌方式实现API接口调用.基于accessToken实现API调用(微信开发)

基于AccessToken方式实现开放平台
    开放平台提供者:需要提供为每个合作机构提供对应的AppID AppSecret
        需要AppId+AppSecret生成对应的accessToken
    1.需求:A需要调用B的服务器(B需要提供开放外网访问接口)
    2.基于令牌方式实现
    AppId (第三方合作机构) 区分不同的机构 永远不能改变
    AppSecret 在传输中实现加密功能(密钥) 可以发生改变
获取AccessToken 开发步骤
    使用对应机构的 AppId + AppSecret 对应生成AccessToken
    使用对应的AccessToken调用第三方接口
    写一个定时Job 每间隔1小时刷新AccessToken


前端:控制我们整个页面跳转 数据展示 页面渲染
后端:核心应该写我们的业务逻辑层,提供数据源

实现前后端分离架构模式.整体项目,采用前后端分离架构模式,前端调用后端接口实现对页面的跳转 数据渲染

前端:看公司API文档接口文档 根据接口文档展示数据
    交互使用http+json

微服务架构模式特征:使用前后端分离架构,目的实现效率开发
前端架构模式:能够去实现对我们的接口复用.

Oauth2.0应用场景 授权管理(QQ 微信联合登录)
oauth2.0认证原理
搭建微信授权联合登录
不同的开放平台对接的oauth2.0协议流程都是相同,无非接口地址不同

===========================================================================
oauth2.0原理(appid,appsecret,access_token,openid,回调地址)
OAuth2.0总体处理流程
1 第一步：用户同意授权，获取code
2 第二步：通过code换取网页授权access_token
3 第三步：刷新access_token（如果需要）
4 第四步：拉取用户信息(需scope为 snsapi_userinfo)

步骤:
    1.在微信开放平台申请对应的appid信息
    2.客户端生成登录授权连接
    3.用户在确认微信登录之后,跳转回到回调地址(配置域名权限)
    4.获取授权码code,使用授权码获取对应的AccessToken(调用腾讯接口权限)
    5.使用AccessToken+openId获取用户相关信息(openid 开放userId)
============================================================================

接口网关(微服务SpringCloud组件Zuul网关) 注册中心 负载均衡客户端 http客户端调用工具 链路 网关
网关(过滤器 拦截器)
    网关包含过滤器实现功能,还可以实现Nginx基本功能 反向代理 负载均衡ribbon(本地客户端)
    Nginx是软负载ribbon本地客户端负载均衡(Dubbo原理分析)
网关核心应用场景:路由地址 反向代理 黑名单与白名单 授权安全

Zuul框架使用Java语言编写 Nginx使用C语言编写
Nginx功能比Zuul功能更加强大 Nginx实现反向代理功能性能比Zuul好
SpringCloud 注册中心 生产者消费者 断路器Zuul(网关) 分布式配置中心
Zuul框架是微服务里面某个组件 网关
Nginx针对于服务器.
Nginx不能替代Zuul 日志 权限控制 限流 安全限制(黑名单 白名单)

基于Nginx搭建网关 
    流程:基于域名区分不同反向代理或者局域项目名称区分不同的反向代理
    网关可以解决跨域问题 跨域可以使用网关实现 实现原理:保证域名相同,使用Nginx区分不同的项目路径进行转发跳转.

RPC远程通讯调用原理
基于SpringCloud Zuul搭建网关
    SpringCloud是一套微服务框架 consul实现注册中心(Go语言开发)

传统服务与服务之间通讯url管理 负载均衡 熔断机制 服务降级
使用服务治理管理每个服务与服务之间的依赖关系(注册中心)

服务(SOA)相当于把共同的业务逻辑抽取出来,以接口的形式发布 服务化
注册中心:consul eureka zookeeper

什么是http请求?
    Http协议实际上对Socket技术封装 请求与响应

重定向底层实现原理:为什么会产生2次请求.请求过程是怎么样?
    客户端向服务器发送请求的时候,服务端如果重定向的话,返回状态302给客户端,在响应头中存放localtion对应的值 就是 重定向地址,客户端收到状态码302,直接浏览器本地进行访问
    浏览器获取响应头状态码为302,读取响应头中的localtion,本地(浏览器)实现访问调用


常用加密算法:对称加密和非对称加密 https底层实现(混合加密算法对对称加密和非对称加密)
    对称加密:加密和解密都是同一种密钥.相对非对称密钥不是很安全,但是效率高 DES AES

非对称加密:是会生成一对密钥 公钥(客户端)和私钥(服务端).
    1.如果使用公钥加密,使用私钥解密
    2.如果使用私钥加密,使用公钥解密

加密的目的为了防止非法获取明文数据,防止篡改数据. 使用验签和令牌
https底层协议使用SSL协议,也是使用对称加密进行传输(浏览器自动生成密钥)
混合算法(对称加密和非对称加密)

Socket三次握手
https协议底层采用默认端口号443 or 8443
SSL安全认证传输步骤:
    1.验证证书是否有效
    2.如果证书有效,则会随机生成一个随机数(随机数指的就是对称加密的密钥)
    3.使用公钥加密随机数(密钥)发给服务器端
    4.服务器使用私钥解密随机数(密钥)
    5.服务器端使用该随机数作为密钥加密数据给客户端
    6.如果客户端使用该随机数解密成功
    7.客户端与服务器端通讯使用该随机数(密钥)进行对称加密传输.

证书的作用:
    1.返回一些加密信息
    2.颁发者机构 加密算法 验证 证书有效期
总结:Https分别对称加密和非对称加密
    非对称加密目的是确保对称加密密钥的安全
    确保安全之后使用对称加密传输

http与https协议区别
    端口号:https是443 http是80
https采用加密传输 http采用明文传输
https采用混合加密算法(对称加密 非对称加密)
https比http协议更加安全,但是https效率没有http高    

Nginx配置Https证书
    ssl:on
    listen 443
    ssl...各种配置

解决跨域问题
    1.httpclient转发(不靠谱)
    2.使用过滤器允许接口跨域 响应头设置
    3.Jsonp不支持post 属于前段解决
    4.Nginx解决跨域问题保持域名端口一致性
    5.Nginx可以通过配置文件解决跨域问题
    6.基于微服务网关解决跨域问题,需要保持域名和端口一致性
    7.使用网关代码允许所有服务可以跨域
    8.SpringBoot的注解 @CrossOrigin




分布式缓存架构设计思想
    
Session是存放在服务器端(保存在单个JVM中),返回Session(响应头),客户端存放在SessionId,下次请求的时候直接使用对应的SessionId从服务器中查询对应的Session
分布式Session(Session共享的问题) --直接使用Token

如何写个单个JVM缓存框架?Session Key Value
Map 过期时间 基于Map集合实现JVM缓存框架

Ehcache的主要特性
    多种缓存策略 快速 简单
    缓存数据有两级:内存和磁盘,因此无需担心容量问题
    缓存数据会在虚拟机重启的过程中写入磁盘
    可以通过RMI 可插入API等方式进行分布式缓存
    具有缓存和缓存管理器的侦听接口
    支持多缓存管理器实例,以及一个实例的多个缓存区域
    提供hibernate的缓存实现

缓存与db不同步的情况下如何解决?
    荡魂村需要被清理时(比如空间占用已经接近临界值了),需要使用某种淘汰算法来清理数据.
    FIFO 先进先出 判断被存储的时间 离目前最远的数据优先被淘汰.
    LRU 最近最少使用 判断最近被使用的时间 目前最远的数据优先被淘汰
    LFU 最不经常使用 在一段时间内,数据被使用次数最少,优先被淘汰

@CacheConfig(cacheNames={"userCache"})
使用@Cacheable注解配置缓存.
@CacheConfig 配置缓存基本信息,cacheNames缓存名称.
@Cacheable 该方法查询数据库完毕之后,存入到缓存中.

如何解决缓存与db不同步的问题
    1.直接重启服务器
    2.主动通知

在项目中什么场景下会发生缓存与db不同步的问题
update(修改)或者del(删除)
先修改,修改成功之后,在主动清理缓存(在同一个事务中)

改完了再清缓存 如果修改失败 定时JOB 健康检查

EHcache 主流集群实现方案:
    RMI JMS方式.
EHcache默认不是支持共享 分布式默认支持共享

RMI和RPC理念是相同的,RMI是Java语言中JVM与JMV实现远程调用方式.(不能跨平台)
RPC也属于远程调用技术 PRC底层使用socket 因为http协议底层使用socket技术(基于二进制传输),支持跨语言跨平台.

目前来说大多数都是用rpc技术.

redis是一个非关系型数据库(NoSql) 内存数据库, 以key value方式进行存储.Redis以单线程方式进行存储.可以保证线程安全问题.可以设置有效期,使用持久化机制保证数据高可用.
redis使用场景
    1.令牌生成(临时 有效期)
    2.短信验证码(临时 有效期)
    3.热点数据(使用redis减轻查询数据库压力)
    4.使用redis实现消息中间件(发布订阅)
    5.分布式锁(使用zk或者redis实现分布式锁)
    6.网站计数器(因为redis是单线程,在高并发情况下,保证记录全局count唯一性)
redis解决雪崩效应
redis多种集群方案
redis持久化机制
redis哨兵机制高可用


redis 允许ip方式 redis.conf  bind属性

redis 5种基本类型
    String hash list set zset

Spring整合redis
redis默认16个库,默认连接0库 以不同的业务区分不同的库

1.什么是主从复制(主Master) (从Slave)
    将服务器分为主服务和从服务器,住的服务可以允许做读写操作,从服务器只允许做读的操作
2.主从复制应用场景:
    集群(多台服务器) 读写分离 日志备份 高可用
3.什么是读写分离
    读和写分库连接,读一个库,写一个库.互相不想赢,增加整体吞吐量
    主服务器可以做写,从服务器可以读.
4.读写分离问题:集群同步问题(redis已经自带)
    
哨兵机制的作用:管理集群redis 监控选举策略 心跳检测 (独立的一个应用程序)
环境配置:实现3台不同服务器的redis实现集群(克隆)  --直接安装一台,后面两台全部克隆

SpringBoot+redis+ehcache 实现二级缓存
    ehcache本地缓存
    redis分布式缓存共享
    一级缓存(ehcache) 和二级缓存(redis) 先走本地,如果本地没有在走网络.
redis与数据库的区别
    相同:都属于中间件形式
    不同点:存放介质 存放在内存中  数据库数据是存在硬盘上

ehcache的优点是本地内存获取.可以充当redis的二级缓存
    可以减轻redis的访问压力 也可以提高访问速度.
问题:过期时间如何控制?(如何同步)?
    一级缓存过期时间比二级缓存过期时间短
    redis和 ehcache 缓存值不同步 定时JOB MQ通知
    
常见redis集群方案对比
    持久化AOF RDB
    AOF是以日志形式记录文件(实时),效率低.
    RDB间隔(非实时),停止的会保存rdb日志文件.效率高(独立进程方式)
RedisCluster分片集群原理分析
虚拟机搭建RedisCluster集群
SpringBoot整合Redis集群

redis3.0之前和redis3.0之后差别大
    redis3.0之后默认支持了redis集群,3.0之前默认不值钱redis集群

redis集群方案:
    1.客户端分片技术(mycat)故障转移功能
    2.主从复制(实现集群)缺点:数据冗余,浪费内存,日志备份
    3.使用代理工具
    4.redis强烈推荐(redis-Cluster)redis3,0之后开始实现
搭建redis集群可以使用伪集群方式(基于端口号进行区分)

redis集群是否支持事务
    redis集群默认不支持事务 但是事务可以在单独节点上可以支持
常见redis攻击手段
redis雪崩效应产生原因
redis雪崩效应解决方案
    1.分布式锁(本地锁)
    2.使用消息中间件方式(最靠谱) 消息中间件方式可以解决高并发
        思路:如果大量请求进行访问的时候,如果redis没有值得情况下,会将该消息存放在消息中间件(异步)
        如果redis查询不到结果的时候,直接将消息扔给消息中间件
    3.一级和二级(redis+ehcache)
    4.均摊分配redis key的失效时间
redis穿透产生原因
redis穿透解决方案 

使用分布式锁(本地锁)解决雪崩效应
    当突然有大量的请求到数据库服务器的时候,进行对数据库服务请求限制.
    可以使用锁的机制,保证只有一个线程(请求)进行数据库的操作访问,否则情况直接排队等待.(如果是集群服务器的话,那么就需要使用分布式锁,单机版本可以使用本地锁)
    可以解决服务雪崩效应,但是会减少服务器吞吐量的问题.

redis穿透原理
    穿透问题产生的原因:客户端随机生成不同的key,在redis缓存中没有该数据,数据库中也没有该数据,这样话可以会导致一直发生JDBC请求连接.
    使用对应的key与数据库中数据不存在.
如何解决穿透问题?
    1.网关判断客户端传入对应的key规则,如果不符合数据库查询的规则会直接返回空
    2.如果使用的key数据查询不到结果的时候,直接在redis中存一份为null的结果.
        问题:如果以后数据库中存放在一个id为4,因为redis存放为null,数据库为4.
        答案:在存入id为4的时候,直接清除对应redis为4的缓存,然后在插入数据库中.

1.zookeeper是一个分布式协调工具(Java语言编写开源框架)
2.zookeeper应用场景
    a.命名服务(注册中心)Dubbo注册中心
    b.分布式配置中心(SpringCloud Config) 动态管理配置文件信息
    c.消息中间件 事件通知(类似于发布订阅功能)
    d.zookeeper分布式事务(全局协调者)
    e.zookeeper实现分布式锁
    f.zookeeper可以实现选举策略(哨兵机制)
    g.zookeeper实现本地动态负载均衡(Dubbo服务负载均衡原理)
    h.消息中间件集群管理(zookeeper)

注册中心都是集群版本 consul eureka zookeeper redis高可用
分布式系统核心在于服务治理 

1.zookeeper存储结构
    xml是怎么样的数据结构? 类似于树Node节点的结构
    zookeeper以节点方式进行存储,类似xml树状结构(目录结构)
    node是如何划分的,node(节点)节点路径、节点value
    节点路径(节点名称),接名称是否允许重复(不能) 保证整体路径的唯一(同一层要唯一)
    节点类型:临时节点 持久节点
        持久节点:创建节点永久的持久化在硬盘上
        临时节点:当前节点和会话连接保持,如果连接断开,该节点也会被删除(分布式锁原理底层用的就是临时节点)
        节点事件通知:每个节点都有事件通知,对该节点发生删除 修改 添加都会有事件通知.类似于消息中间件功能
2.基于zk实现动态本地负载均衡(Dubbo服务调用负载均衡)
    会员服务项目启动的时候回在zk上创建一个临时节点 节点名称itmayiedu_member对应的value:127.0.0.1:8080,127.0.0.1:8081
    订单直接在zk使用itmayiedu_member查询下面所有子节点,获取子节点后,本地在使用负载均衡算法实现调用

将服务注册到zookeeper上
    1.建立zk连接
    2.先创建父节点
        如果父节点不存在,直接创建父节点
    3.创建子节点(临时)

客户端从zk服务器端获取节点信息
    1.建立zk节点
    2.读取注册父节点信息
    
如何使用zookeeper实现分布式锁?思路?
    zookeeper实现分布式锁 使用临时节点实现.
实现步骤:多个JVM同时在zookeeper上创建同一个相同的节点(/lock),因为zookeeper节点是唯一的,
    如果是唯一的话,那么同时如果有多个客户端创建相同的节点/lock的话,最终只有看谁快速抢夺资源,谁就能创建/lock节点
    这个时候节点类型应该使用临时类型.

zookeeper如何获取锁?
zookeeper如何释放锁?
    使用watcher(事件通知)获取/lock已经被删除
zk连接不要强制关闭,会产生延迟.直接调用close(),产生延迟的概率非常小.
如果程序一直不处理完,可能导致死锁?可以设置有效期.可以看60秒session超时
rpc重试 一般重试3次


Nginx策略
    轮询 权重 随机 ip URL

并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。


Servlet 生命周期就是指创建 Servlet 实例后响应客户请求直至销毁的全过程.
Serlvet 生命周期的三个方法:init()–>service()–>destroy()，
Servlet生命周期的各个阶段: 实例化:Servlet 容器创建
Servlet 类的实例对象
初始化:Servlet 容器调用 Servlet 的 init()方法
服务:如果请求 Servlet,则容器调用 service()方法
销毁:销毁实例之前调用 destroy()方法

分布式Session一致性(服务器集群Session共享问题)
Session的作用? 记录用户信息(应用场景)
应用场景:JavaEE基础登录流程做法(账号密码登录成功之后,获取到userId 存放在Session 下次获取用户信息之后 直接从session会话中获取) 防止表单重复提交 

Session理解为JVM本地缓存  session存在服务器上 返回SessionId给客户端

Session原理?
Session常见的问题:
    浏览器关闭了Session?Session会失效么?

默认创建一个Session 默认值为true 没有找到对应的Session自动创建Session
HttpSession session = request.getSession();
session分为sessionid和sessionvalue
session本身是一个临时的 sessionId和token(令牌)非常相似  保证临时且唯一

(请求和响应过程)
服务器端接收到客户端请求 会创建一个session 使用响应头返回sessionId给客户端 浏览器获取到sessionId后保存到本地.cookie
(第二次请求)
客户端读取到本地的sessionId存放在请求头中 服务器端从请求头中获取到对应的sessionId,通过SessionId在本地session内存中查询

1.分布式Session问题 因为Session存放在服务器端 SessionId对应找不到Session
2.分布式任务调度平台(服务器集群之后如何保证定时JOB的唯一性)  幂等性
3.分布式锁解决方案 (全局ID)
    基于Zookeeper使用临时节点+事件通知
    基于redis setnx方式缺点: 不推荐 代码复杂 死锁
    redisson
    SpringCloud对redisson redis中提供很多关于分布式解决方案 分布式锁
4.分布式日志收集问题
    elk 大型的电商互联网内部分布式日志收集
5.分布式事务问题(跟集群没有关系) rpc远程通讯服务与服务之间实现事务管理.
    如何纯手写一个自己分布式事务解决框架 模仿lcn
6.分布式配置中心(跟集群没有关系) 
面试官经常问你道题:你在做项目的时候,遇到过哪些问题?


分布式服务器集群session共享问题
分布式session解决方案?
    可以直接使用cookie替代Session(不靠谱)
    使用Nginx 反向代理 IP hash IP绑定方式 同一个IP 只能在指定的同一个机器访问(没有负载均衡)
    使用数据库效率不是很高
    tomcat内置支持对session同步(不推荐) 同步可能会产生延迟
    使用Spring-Session框架相当于把我们Session缓存到redis中
    使用token替代Session功能

面试题:项目在发布时候,Session如何控制不失效?
    使用缓存框架 缓存Session的值(一级 和 二级)
    Spring-Session重写httpSession框架 将对应的值缓存到redis中 有点类似于一级缓存 二级缓存
    SessionId不同 它的域名也不同
    移动会话信息使用令牌token方式替代Session
    Token最终存放在redis中 redis支持分布式共享

基于token令牌方式解决Session共享
使用Zookeeper实现服务Master选举
    哨兵机制回顾:目的是为了主和选举策略 实现高可用
    主只能有一台主节点多个从节点
    原理:多个服务器在启动的时候,会在Zookeeper上面创建相同的临时节点,谁如果能够创建成功,谁就为主(因节点保证唯一),如果主服务器宕机之后,会话连接也会失效.其他服务器又开始重新选举.
    其他从节点使用事件监听,如果当节点被删除的情况下,这时候重新开始选举.


网站跨域请求问题
1.解决跨域问题使用jsonp
2.什么是跨域问题
    两个项目之前使用ajax(前端类似于后端技术HTTPClient)实现通讯,
    如果浏览器访问的域名地址与ajax访问的地址不一致的情况,默认情况下浏览器会有安全机制,这个机制跨域问题,会无法获取到返回结果.
    注意:每个项目的端口号是否相同
    如果ajax访问地址与浏览器访问域名和端口号都不同的情况下,默认浏览器会有安全策略,直接无法获取请求结果.
3.为什么会产生跨域问题
    浏览器跨域问题产生的原因,如果使用ajax请求使用第三方接口,如果ajax访问的接口域名和端口号与浏览器访问的域名和端口号不一致的情况下,就会产生跨域问题(属于浏览器安全策略)
    跨域不属于前端问题
    跨域问题,请求时可以访问的,但只是获取不到结果
4.如何彻底解决网站跨域问题
    使用jsonp解决跨域问题(只能支持get请求 不支持post请求) dataType:"jsonp"
    使用HttpClient进行转发(效率低 会发送两次请求 后端转发 避免跨域)
    设置响应头允许跨域 reponse.setHeader("Access-Control-Allow-Origin"."*");
    使用Nginx搭建API接口网关(因为保证域名和端口都一致,以项目区分反向代理到真是服务器地址)
        原理:保证域名和端口号都是相同的,根据项目区分不同名称使用nginx进行转发到真实服务器地址,可以彻底解决网站跨域问题,而且可以保证整套系统安全性的问题.
    使用Zuul微服务搭建API接口网关 SpringCloud
        原理:application.yml 项目名称区别不同项目地址 需要Eurke zk注册中心管理 zuul路由转发 

Nginx服务器模块
微服务通讯会产生跨域问题? rpc之间通讯会产生跨域问题?
    不会,因为走后端访问.


为什么要实现zookeeper集群呢?服务如果要实现集群的话?目的保证整套系统的一个高可用

服务器集群和注册中心集群的目的是什么?
相同点:都是为了保证高可用 如果某个服务实现宕机可以做故障转移fallback
服务器集群是为了解决高并发
注册集群担心如果是单台注册中心节点的时候,如果宕机之后可能导致整个微服务无法通讯
注册中心实际上服务治理 管理每个服务指向url地址

zookeeper实现集群选举原理?





