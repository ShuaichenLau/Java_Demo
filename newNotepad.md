@RestController 和 @Controller的区别
    @RestController是组合注解,是@ResponseBody注解和@Controller注解的组合.

count(1) count(*) count(列名)的区别
    从执行计划来看，count(1)和count(*)的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。
    如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。
    因为count(*),自动会优化指定到那一个字段。所以没必要去count(1)，用count(*)，sql会帮你完成优化的。
    在执行效果上:
        1.count(1)会统计表中所有的记录数 (包含字段为null的记录);
        2.count(字段)会统计该字段在表中出现的次数,忽略字段为null的情况 (不统计字段为null的记录);
        3.count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL;
        4.count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL;
        5.count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    在执行效率上:
        1.列名为主键,count(列名)会比count(1)快;
        2.列名不为主键,count(1)会比count(列名)快;
        3.如果表多个列并且没有主键,则count(1)的执行效率要优于count(*);
        4.如果有主键,则select count(主键)执行效率是最好的;
        5.如果表只有一个字段,则select count(*)执行效率是最好的;

1、equals(Object o) 因为原equals方法中的参数类型是封装类型，所传入的参数类型（a）是原始数据类型，所以会自动对其装箱，反之，会对其进行拆箱
2、当两种不同类型用==比较时，包装器类的需要拆箱， 当同种类型用==比较时，会自动拆箱或者装箱



1 JUC是怎么用的?
    a.线程间通信工具类,Semaphore、CountDownLatch、Future.在写多线程高并发的程序时，结合通信工具和锁把线程编排的符合你的预期执行
    b.锁,JUC提供了某些场景下比synchronized更合适的高级锁出现,包括读写锁 互斥锁等等,多数基于cas这种乐观锁实现,性能要由于synchronized内置锁,而且Condition更灵活可控.
    c.原子包装类
    d.线程安全的集合 基于锁分解、分段锁、CAS等机制性能优良且线程安全的集合类，一般在多线程业务中，只要有共享访问的集合，可能不管三七二十一直接用这些同步集合
    e.线程池工具类
2 用过哪些设计模式?
    单例模式 双重校验锁 Emun枚举
    抽象工厂模式 比如车险 农险 人寿险 等等,它们险种不一样,但是都有一种同样的抽象概念,比如说都有相同的保险起止期,等等这些.把相同的属性抽象成父类,特有的属性为子类特有.
    生产者消费者模式 比如说kafka mq 以及听云产品业务前后端分离架构
3 1.8 JVM有哪些优化
4 1.7 1.8 currentHashMap有什么优化
5 提交事务 事务回滚是怎么弄的
    MySQL事务
    https://www.runoob.com/mysql/mysql-transaction.html
6 分布式事务是怎么做的?
7 redis 热搜排序是怎么做的
8 线程池 线程的创建方式
    线程的创建方式
        a.实现Runnable接口
        b.继承Thread类
        c.实现Callable接口
9 object有哪些方法
10 @SpringBootApplication注解有什么作用
11 mq (这个我说不是很了解  只是写过简单的demo)
12 缓存穿透 雪崩 是怎么解决的
13 redis有哪些应用场景
14 创建对象有哪些方式
15 redis持久化的问题
16 MySQL索引是怎么用的 怎么创建索引 索引原理是什么  SQL的优化 explain
17 MySQL  一二三范式  数据库是怎么设计的
18 SpringIOC  AOP

内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存

内存泄漏 内存溢出
泄漏就是内存申请后，用完没有释放，造成可用内存越来越少。
溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常，严重的，攻击者可以以此获取程序控制权。

数据库事务特性ACID
	A原子性:事务是一个完整的操作.事务的各步操作是不可分的(原子的);要么都执行,要么都不执行
	C一致性:当事务完成时,数据都必须是一致的状态
	I隔离性:对数据进行修改的所有并发事务都是彼此隔离的,这表示事务必须是独立的,不应以任何方式依赖于或影响其他事务
	D持久性:事务完成时,对数据库的修改被永久保持,事务日志能保持事务的永久性.

第一范式:
    保持每列的原子性,每一列都是不可拆分的最小单元.(最小的单元,列都是不可再拆分的)
第二范式:
    满足第一范式,并且表中非主键列不存在对主键的部分依赖(每个表只描述一件事)
第三范式:
    满足第二范式,并且表中的列不存在对非主键列的传递依赖.

redis持久化
    aof append的方式持久化
    rdb 生成快照的方式
save命令
    同步生成快照 同时会阻塞所有来自客户端请求,如果数据较大的话,会导致服务长时间不能响应
bgsave命令
    异步生成快照 同时接收所有来自客户端的请求,通过lastSave命令获取最近一次成功执行快照的时间

表单重复提交问题
    rpc远程调用的时候 网络发生延迟的时候 可能会有重试机制
互联网API接口幂等性设计 ## 如何纯手写一个互联网API接口幂等性框架
保证互联网接口幂等性问题
API接口与RPC远程http协议
API幂等性产生的原因:(接口重复提交的问题) 保证接口唯一性 使用token(令牌)保证临时且唯一(15分钟-120分钟)
分布式session解决方案 使用redis+token
token如何生成 token_时间戳(雪花算法ID)  分布式场景问题

如何保证外网开放接口的安全性
    1.搭建API网关控制接口访问权限
    2.开放平台设计oauth2.0协议(安全认证) QQ认证 第三方联合登录
    3.采用https加密传输协议(使用Nginx配置Https)
    4.API接口数字签名(移动的接口)非对称加密RSA 防止抓包分析修改数据
    5.基于令牌方式实现API接口调用.基于accessToken实现API调用(微信开发)

基于AccessToken方式实现开放平台
    开放平台提供者:需要提供为每个合作机构提供对应的AppID AppSecret
        需要AppId+AppSecret生成对应的accessToken
    1.需求:A需要调用B的服务器(B需要提供开放外网访问接口)
    2.基于令牌方式实现
    AppId (第三方合作机构) 区分不同的机构 永远不能改变
    AppSecret 在传输中实现加密功能(密钥) 可以发生改变
获取AccessToken 开发步骤
    使用对应机构的 AppId + AppSecret 对应生成AccessToken
    使用对应的AccessToken调用第三方接口
    写一个定时Job 每间隔1小时刷新AccessToken